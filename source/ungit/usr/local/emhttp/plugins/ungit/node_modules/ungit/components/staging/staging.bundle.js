(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var programEvents = require('ungit-program-events');
var _ = require('lodash');
var filesToDisplayIncrmentBy = 50;
var filesToDisplayLimit = filesToDisplayIncrmentBy;
// when discard button is clicked and disable discard warning is selected, for next 5 minutes disable discard warnings
var muteGraceTimeDuration = 60 * 1000 * 5;

components.register('staging', function(args) {
  return new StagingViewModel(args.server, args.repoPath);
});

var StagingViewModel = function(server, repoPath) {
  var self = this;
  this.server = server;
  this.repoPath = repoPath;
  this.filesByPath = {};
  this.files = ko.observableArray();
  this.commitMessageTitleCount = ko.observable(0);
  this.commitMessageTitle = ko.observable();
  this.commitMessageTitle.subscribe(function(value) {
    self.commitMessageTitleCount(value.length);
  });
  this.commitMessageBody = ko.observable();
  this.wordWrap = ko.observable(false);
  this.inRebase = ko.observable(false);
  this.inMerge = ko.observable(false);
  this.inCherry = ko.observable(false);
  this.conflictText = ko.computed(function() {
    if (self.inMerge()) {
      self.conflictContinue = self.conflictResolution.bind(self, '/merge/continue', self.conflictContinueProgressBar)
      self.conflictAbort = self.conflictResolution.bind(self, '/merge/abort', self.conflictAbortProgressBar)
      return "Merge";
    } else if (self.inRebase()) {
      self.conflictContinue = self.conflictResolution.bind(self, '/rebase/continue', self.conflictContinueProgressBar)
      self.conflictAbort = self.conflictResolution.bind(self, '/rebase/abort', self.conflictAbortProgressBar)
      return "Rebase";
    } else if (self.inCherry()) {
      self.conflictContinue = self.commit;
      self.conflictAbort = self.discardAllChanges;
      return "Cherry-pick";
    } else {
      self.conflictContinue = undefined;
      self.conflictAbort = undefined;
      return undefined;
    }
  });
  this.allStageFlag = ko.observable(false);
  this.HEAD = ko.observable();
  this.isStageValid = ko.computed(function() {
    return !self.inRebase() && !self.inMerge() && !self.inCherry();
  });
  this.nFiles = ko.computed(function() {
    return self.files().length;
  });
  this.nStagedFiles = ko.computed(function() {
    return self.files().filter(function(f) { return f.editState() === 'staged'; }).length;
  });
  this.stats = ko.computed(function() {
    return self.nFiles() + ' files, ' + self.nStagedFiles() + ' to be commited';
  });
  this.amend = ko.observable(false);
  this.canAmend = ko.computed(function() {
    return self.HEAD() && !self.inRebase() && !self.inMerge();
  });
  this.canStashAll = ko.computed(function() {
    return !self.amend();
  });
  this.showNux = ko.computed(function() {
    return self.files().length == 0 && !self.amend() && !self.inRebase();
  });
  this.committingProgressBar = components.create('progressBar', { predictionMemoryKey: 'committing-' + this.repoPath(), temporary: true });
  this.conflictContinueProgressBar = components.create('progressBar', { predictionMemoryKey: 'conflict-continue-' + this.repoPath(), temporary: true });
  this.conflictAbortProgressBar = components.create('progressBar', { predictionMemoryKey: 'conflict-abort-' + this.repoPath(), temporary: true });
  this.stashProgressBar = components.create('progressBar', { predictionMemoryKey: 'stash-' + this.repoPath(), temporary: true });
  this.commitValidationError = ko.computed(function() {
    if (!self.amend() && !self.files().some(function(file) { return file.editState() === 'staged' || file.editState() === 'patched'; }))
      return "No files to commit";

    if (self.files().some(function(file) { return file.conflict(); }))
      return "Files in conflict";

    if (!self.commitMessageTitle() && !self.inRebase()) return "Provide a title";

    if (self.textDiffType() === 'sidebysidediff') {
      var patchFiles = self.files().filter(function(file) { return file.editState() === 'patched'; });
      if (patchFiles.length > 0) return "Cannot patch with side by side view."
    }

    return "";
  });
  this.toggleSelectAllGlyphClass = ko.computed(function() {
    if (self.allStageFlag()) return 'glyphicon-unchecked';
    else return 'glyphicon-check';
  });

  this.refreshContentThrottled = _.throttle(this.refreshContent.bind(this), 400, { trailing: true });
  this.invalidateFilesDiffsThrottled = _.throttle(this.invalidateFilesDiffs.bind(this), 400, { trailing: true });
  this.refreshContentThrottled();
  this.textDiffType = ko.observable('textdiff');
  if (window.location.search.indexOf('noheader=true') >= 0)
    this.refreshButton = components.create('refreshbutton');
  this.loadAnyway = false;
  this.isDiagOpen = false;
  this.mutedTime = null;
}
StagingViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('staging', this, {}, parentElement);
}
StagingViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'request-app-content-refresh') {
    this.refreshContent();
    this.invalidateFilesDiffs();
  }
  if (event.event == 'working-tree-changed') {
    this.refreshContentThrottled();
    this.invalidateFilesDiffsThrottled();
  }
}
StagingViewModel.prototype.refreshContent = function(callback) {
  var self = this;
  this.server.get('/head', { path: this.repoPath(), limit: 1 }, function(err, log) {
    if (err) {
      return err.errorCode == 'must-be-in-working-tree' ||
        err.errorCode == 'no-such-path';
    }
    if (log.length > 0) {
      var array = log[0].message.split('\n');
      self.HEAD({title: array[0], body: array.slice(2).join('\n')});
    }
    else self.HEAD(null);
  });
  this.server.get('/status', { path: this.repoPath(), fileLimit: filesToDisplayLimit }, function(err, status) {
    if (err) {
      if (callback) callback(err);
      return err.errorCode == 'must-be-in-working-tree' ||
        err.errorCode == 'no-such-path';
    }

    if (Object.keys(status.files).length > filesToDisplayLimit && !self.loadAnyway) {
      if (self.isDiagOpen) {
        if (callback) callback();
        return;
      }
      self.isDiagOpen = true;
      var diag = components.create('TooManyFilesDialogViewModel', { title: 'Too many unstaged files', details: 'It is recommended to use command line as ungit may be too slow.'});

      diag.closed.add(function() {
        self.isDiagOpen = false;
        if (diag.result()) {
          self.loadAnyway = true;
          self.loadStatus(status, callback);
        } else {
          window.location.href = '/#/';
        }
      })

      programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
    } else {
      self.loadStatus(status, callback);
    }
  });
}
StagingViewModel.prototype.loadStatus = function(status, callback) {
  this.setFiles(status.files);
  this.inRebase(!!status.inRebase);
  this.inMerge(!!status.inMerge);
  // There are time where '.git/CHERRY_PICK_HEAD' file is created and no files are in conflicts.
  // in such cases we should ignore exception as no good way to resolve it.
  this.inCherry(!!status.inCherry && !!status.inConflict);

  if (this.inRebase()) {
    this.commitMessageTitle('Rebase conflict');
    this.commitMessageBody('Commit messages are not applicable!\n(╯°□°）╯︵ ┻━┻');
  } else if (this.inMerge() || this.inCherry()) {
    var lines = status.commitMessage.split('\n');
    this.commitMessageTitle(lines[0]);
    this.commitMessageBody(lines.slice(1).join('\n'));
  }
  if (callback) callback();
}
StagingViewModel.prototype.setFiles = function(files) {
  var self = this;
  var newFiles = [];
  for(var file in files) {
    var fileViewModel = this.filesByPath[file];
    if (!fileViewModel) {
      this.filesByPath[file] = fileViewModel = new FileViewModel(self, file, self.textDiffType, self.wordWrap);
    } else {
      // this is mainly for patching and it may not fire due to the fact that
      // '/commit' triggers working-tree-changed which triggers throttled refresh
      fileViewModel.invalidateDiff();
    }
    fileViewModel.setState(files[file]);
    newFiles.push(fileViewModel);
  }
  this.files(newFiles);
  programEvents.dispatch({ event: 'init-tooltip' });
}
StagingViewModel.prototype.toggleAmend = function() {
  if (!this.amend() && !this.commitMessageTitle()) {
    this.commitMessageTitle(this.HEAD().title);
    this.commitMessageBody(this.HEAD().body);
  }
  else if(this.amend()) {
    var isPrevDefaultMsg =
      this.commitMessageTitle() == this.HEAD().title &&
      this.commitMessageBody() == this.HEAD().body;
    if (isPrevDefaultMsg) {
      this.commitMessageTitle('');
      this.commitMessageBody('');
    }
  }
  this.amend(!this.amend());
}
StagingViewModel.prototype.resetMessages = function() {
  this.commitMessageTitle('');
  this.commitMessageBody('');
  this.amend(false);
}
StagingViewModel.prototype.commit = function() {
  var self = this;
  this.committingProgressBar.start();
  var files = this.files().filter(function(file) {
    return file.editState() !== 'none';
  }).map(function(file) {
    return { name: file.name(), patchLineList: file.editState() === 'patched' ? file.patchLineList() : null };
  });
  var commitMessage = this.commitMessageTitle();
  if (this.commitMessageBody()) commitMessage += '\n\n' + this.commitMessageBody();
  this.server.post('/commit', { path: this.repoPath(), message: commitMessage, files: files, amend: this.amend() }, function(err, res) {
    self.committingProgressBar.stop();
    if (err) {
      return;
    }
    self.resetMessages();
    self.files([]);
  });
}
StagingViewModel.prototype.conflictResolution = function(apiPath, progressBar) {
  var self = this;
  progressBar.start();
  var commitMessage = this.commitMessageTitle();
  if (this.commitMessageBody()) commitMessage += '\n\n' + this.commitMessageBody();
  this.server.post(apiPath, { path: this.repoPath(), message: commitMessage }, function(err, res) {
    self.resetMessages();
    progressBar.stop();
  });
}
StagingViewModel.prototype.invalidateFilesDiffs = function() {
  this.files().forEach(function(file) {
    file.diff().invalidateDiff();
  });
}
StagingViewModel.prototype.discardAllChanges = function() {
  var self = this;
  var diag = components.create('yesnodialog', { title: 'Are you sure you want to discard all changes?', details: 'This operation cannot be undone.'});
  diag.closed.add(function() {
    if (diag.result()) self.server.post('/discardchanges', { path: self.repoPath(), all: true });
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}
StagingViewModel.prototype.stashAll = function() {
  var self = this;
  this.stashProgressBar.start();
  this.server.post('/stashes', { path: this.repoPath(), message: this.commitMessageTitle() }, function(err, res) {
    self.stashProgressBar.stop();
  });
}
StagingViewModel.prototype.toggleAllStages = function() {
  var self = this;
  for (var n in self.files()){
    self.files()[n].editState(self.allStageFlag() ? 'staged' : 'none');
  }

  self.allStageFlag(!self.allStageFlag());
}
StagingViewModel.prototype.textDiffTypeChange = function(type) {
  this.textDiffType(type);
}
StagingViewModel.prototype.onEnter = function(d, e){
    if (e.keyCode === 13 && !this.commitValidationError()) {
      this.commit();
    }
    return true;
};
StagingViewModel.prototype.onAltEnter = function(d, e){
    if (e.keyCode === 13 && e.altKey && !this.commitValidationError()) {
      this.commit();
    }
    return true;
};
StagingViewModel.prototype.toggleWordWrap = function(state) {
  this.wordWrap(state);
};

var FileViewModel = function(staging, name, textDiffType, wordWrap) {
  var self = this;
  this.staging = staging;
  this.server = staging.server;
  this.editState = ko.observable('staged'); // staged, patched and none
  this.name = ko.observable(name);
  this.displayName = ko.observable(name);
  this.isNew = ko.observable(false);
  this.removed = ko.observable(false);
  this.conflict = ko.observable(false);
  this.renamed = ko.observable(false);
  this.isShowingDiffs = ko.observable(false);
  this.diffProgressBar = components.create('progressBar', { predictionMemoryKey: 'diffs-' + this.staging.repoPath(), temporary: true });
  this.isShowingDiffs = ko.observable(false);
  this.textDiffType = textDiffType;
  this.wordWrap = wordWrap;
  this.additions = ko.observable('');
  this.deletions = ko.observable('');
  this.fileType = ko.observable('text');
  this.patchLineList = ko.observableArray();
  this.diff = ko.observable();
  this.isShowPatch = ko.computed(function() {
    // if not new file
    // and if not merging
    // and if not rebasing
    // and if text file
    // and if diff is showing, display patch button
    return !self.isNew() && !staging.inMerge() && !staging.inRebase() && self.fileType() === 'text' && self.isShowingDiffs();
  });

  this.editState.subscribe(function (value) {
    if (value === 'none') {
      self.patchLineList([]);
    } else if (value === 'patched') {
      if (self.diff().render) self.diff().render();
    }
  });
}
FileViewModel.prototype.getSpecificDiff = function() {
  return components.create(!this.name() || this.fileType() + 'diff', {
    filename: this.name(),
    repoPath: this.staging.repoPath,
    server: this.server,
    textDiffType: this.textDiffType,
    isShowingDiffs: this.isShowingDiffs,
    diffProgressBar: this.diffProgressBar,
    patchLineList: this.patchLineList,
    editState: this.editState,
    wordWrap: this.wordWrap
  });
}
FileViewModel.prototype.setState = function(state) {
  this.displayName(state.displayName);
  this.isNew(state.isNew);
  this.removed(state.removed);
  this.conflict(state.conflict);
  this.renamed(state.renamed);
  this.fileType(state.type);
  this.additions(state.additions != '-' ? '+' + state.additions : '');
  this.deletions(state.deletions != '-' ? '-' + state.deletions : '');
  this.diff = ko.observable(this.getSpecificDiff());
  if (this.diff().isNew) this.diff().isNew(state.isNew);
  if (this.diff().isRemoved) this.diff().isRemoved(state.removed);
}
FileViewModel.prototype.toggleStaged = function() {
  if (this.editState() === 'none') {
    this.editState('staged');
  } else {
    this.editState('none');
  }
  this.patchLineList([]);
}
FileViewModel.prototype.discardChanges = function() {
  var self = this;
  if (ungit.config.disableDiscardWarning || new Date().getTime() - this.staging.mutedTime < ungit.config.disableDiscardMuteTime) {
    self.server.post('/discardchanges', { path: self.staging.repoPath(), file: self.name() });
  } else {
    var diag = components.create('yesnomutedialog', { title: 'Are you sure you want to discard these changes?', details: 'This operation cannot be undone.'});
    diag.closed.add(function() {
      if (diag.result()) self.server.post('/discardchanges', { path: self.staging.repoPath(), file: self.name() });
      if (diag.result() === "mute") self.staging.mutedTime = new Date().getTime();
    });
    programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
  }
}
FileViewModel.prototype.ignoreFile = function() {
  var self = this;
  this.server.post('/ignorefile', { path: this.staging.repoPath(), file: this.name() }, function(err) {
    if (err && err.errorCode == 'file-already-git-ignored') {
      // The file was already in the .gitignore, so force an update of the staging area (to hopefull clear away this file)
      programEvents.dispatch({ event: 'working-tree-changed' });
      return true;
    }
  });
}
FileViewModel.prototype.resolveConflict = function() {
  this.server.post('/resolveconflicts', { path: this.staging.repoPath(), files: [this.name()] });
}
FileViewModel.prototype.toggleDiffs = function() {
  if (this.renamed()) return; // do not show diffs for renames
  if (this.isShowingDiffs()) {
    this.isShowingDiffs(false);
  } else {
    this.isShowingDiffs(true);
    this.invalidateDiff();
  }
}
FileViewModel.prototype.patchClick = function() {
  if (!this.isShowingDiffs()) return;

  if (this.editState() === 'patched') {
    this.editState('staged');
  } else {
    this.editState('patched');
  }
}
FileViewModel.prototype.invalidateDiff = function() {
  this.diff().invalidateDiff();
}

},{"knockout":"knockout","lodash":"lodash","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3N0YWdpbmcvc3RhZ2luZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG52YXIgZmlsZXNUb0Rpc3BsYXlJbmNybWVudEJ5ID0gNTA7XG52YXIgZmlsZXNUb0Rpc3BsYXlMaW1pdCA9IGZpbGVzVG9EaXNwbGF5SW5jcm1lbnRCeTtcbi8vIHdoZW4gZGlzY2FyZCBidXR0b24gaXMgY2xpY2tlZCBhbmQgZGlzYWJsZSBkaXNjYXJkIHdhcm5pbmcgaXMgc2VsZWN0ZWQsIGZvciBuZXh0IDUgbWludXRlcyBkaXNhYmxlIGRpc2NhcmQgd2FybmluZ3NcbnZhciBtdXRlR3JhY2VUaW1lRHVyYXRpb24gPSA2MCAqIDEwMDAgKiA1O1xuXG5jb21wb25lbnRzLnJlZ2lzdGVyKCdzdGFnaW5nJywgZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gbmV3IFN0YWdpbmdWaWV3TW9kZWwoYXJncy5zZXJ2ZXIsIGFyZ3MucmVwb1BhdGgpO1xufSk7XG5cbnZhciBTdGFnaW5nVmlld01vZGVsID0gZnVuY3Rpb24oc2VydmVyLCByZXBvUGF0aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICB0aGlzLnJlcG9QYXRoID0gcmVwb1BhdGg7XG4gIHRoaXMuZmlsZXNCeVBhdGggPSB7fTtcbiAgdGhpcy5maWxlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZUNvdW50ID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlLnN1YnNjcmliZShmdW5jdGlvbih2YWx1ZSkge1xuICAgIHNlbGYuY29tbWl0TWVzc2FnZVRpdGxlQ291bnQodmFsdWUubGVuZ3RoKTtcbiAgfSk7XG4gIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMud29yZFdyYXAgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5pblJlYmFzZSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmluTWVyZ2UgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5pbkNoZXJyeSA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNvbmZsaWN0VGV4dCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmluTWVyZ2UoKSkge1xuICAgICAgc2VsZi5jb25mbGljdENvbnRpbnVlID0gc2VsZi5jb25mbGljdFJlc29sdXRpb24uYmluZChzZWxmLCAnL21lcmdlL2NvbnRpbnVlJywgc2VsZi5jb25mbGljdENvbnRpbnVlUHJvZ3Jlc3NCYXIpXG4gICAgICBzZWxmLmNvbmZsaWN0QWJvcnQgPSBzZWxmLmNvbmZsaWN0UmVzb2x1dGlvbi5iaW5kKHNlbGYsICcvbWVyZ2UvYWJvcnQnLCBzZWxmLmNvbmZsaWN0QWJvcnRQcm9ncmVzc0JhcilcbiAgICAgIHJldHVybiBcIk1lcmdlXCI7XG4gICAgfSBlbHNlIGlmIChzZWxmLmluUmViYXNlKCkpIHtcbiAgICAgIHNlbGYuY29uZmxpY3RDb250aW51ZSA9IHNlbGYuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQoc2VsZiwgJy9yZWJhc2UvY29udGludWUnLCBzZWxmLmNvbmZsaWN0Q29udGludWVQcm9ncmVzc0JhcilcbiAgICAgIHNlbGYuY29uZmxpY3RBYm9ydCA9IHNlbGYuY29uZmxpY3RSZXNvbHV0aW9uLmJpbmQoc2VsZiwgJy9yZWJhc2UvYWJvcnQnLCBzZWxmLmNvbmZsaWN0QWJvcnRQcm9ncmVzc0JhcilcbiAgICAgIHJldHVybiBcIlJlYmFzZVwiO1xuICAgIH0gZWxzZSBpZiAoc2VsZi5pbkNoZXJyeSgpKSB7XG4gICAgICBzZWxmLmNvbmZsaWN0Q29udGludWUgPSBzZWxmLmNvbW1pdDtcbiAgICAgIHNlbGYuY29uZmxpY3RBYm9ydCA9IHNlbGYuZGlzY2FyZEFsbENoYW5nZXM7XG4gICAgICByZXR1cm4gXCJDaGVycnktcGlja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmNvbmZsaWN0Q29udGludWUgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLmNvbmZsaWN0QWJvcnQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuYWxsU3RhZ2VGbGFnID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuSEVBRCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5pc1N0YWdlVmFsaWQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXNlbGYuaW5SZWJhc2UoKSAmJiAhc2VsZi5pbk1lcmdlKCkgJiYgIXNlbGYuaW5DaGVycnkoKTtcbiAgfSk7XG4gIHRoaXMubkZpbGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuZmlsZXMoKS5sZW5ndGg7XG4gIH0pO1xuICB0aGlzLm5TdGFnZWRGaWxlcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLmZpbGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYuZWRpdFN0YXRlKCkgPT09ICdzdGFnZWQnOyB9KS5sZW5ndGg7XG4gIH0pO1xuICB0aGlzLnN0YXRzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYubkZpbGVzKCkgKyAnIGZpbGVzLCAnICsgc2VsZi5uU3RhZ2VkRmlsZXMoKSArICcgdG8gYmUgY29tbWl0ZWQnO1xuICB9KTtcbiAgdGhpcy5hbWVuZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmNhbkFtZW5kID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuSEVBRCgpICYmICFzZWxmLmluUmViYXNlKCkgJiYgIXNlbGYuaW5NZXJnZSgpO1xuICB9KTtcbiAgdGhpcy5jYW5TdGFzaEFsbCA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhc2VsZi5hbWVuZCgpO1xuICB9KTtcbiAgdGhpcy5zaG93TnV4ID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuZmlsZXMoKS5sZW5ndGggPT0gMCAmJiAhc2VsZi5hbWVuZCgpICYmICFzZWxmLmluUmViYXNlKCk7XG4gIH0pO1xuICB0aGlzLmNvbW1pdHRpbmdQcm9ncmVzc0JhciA9IGNvbXBvbmVudHMuY3JlYXRlKCdwcm9ncmVzc0JhcicsIHsgcHJlZGljdGlvbk1lbW9yeUtleTogJ2NvbW1pdHRpbmctJyArIHRoaXMucmVwb1BhdGgoKSwgdGVtcG9yYXJ5OiB0cnVlIH0pO1xuICB0aGlzLmNvbmZsaWN0Q29udGludWVQcm9ncmVzc0JhciA9IGNvbXBvbmVudHMuY3JlYXRlKCdwcm9ncmVzc0JhcicsIHsgcHJlZGljdGlvbk1lbW9yeUtleTogJ2NvbmZsaWN0LWNvbnRpbnVlLScgKyB0aGlzLnJlcG9QYXRoKCksIHRlbXBvcmFyeTogdHJ1ZSB9KTtcbiAgdGhpcy5jb25mbGljdEFib3J0UHJvZ3Jlc3NCYXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7IHByZWRpY3Rpb25NZW1vcnlLZXk6ICdjb25mbGljdC1hYm9ydC0nICsgdGhpcy5yZXBvUGF0aCgpLCB0ZW1wb3Jhcnk6IHRydWUgfSk7XG4gIHRoaXMuc3Rhc2hQcm9ncmVzc0JhciA9IGNvbXBvbmVudHMuY3JlYXRlKCdwcm9ncmVzc0JhcicsIHsgcHJlZGljdGlvbk1lbW9yeUtleTogJ3N0YXNoLScgKyB0aGlzLnJlcG9QYXRoKCksIHRlbXBvcmFyeTogdHJ1ZSB9KTtcbiAgdGhpcy5jb21taXRWYWxpZGF0aW9uRXJyb3IgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYuYW1lbmQoKSAmJiAhc2VsZi5maWxlcygpLnNvbWUoZnVuY3Rpb24oZmlsZSkgeyByZXR1cm4gZmlsZS5lZGl0U3RhdGUoKSA9PT0gJ3N0YWdlZCcgfHwgZmlsZS5lZGl0U3RhdGUoKSA9PT0gJ3BhdGNoZWQnOyB9KSlcbiAgICAgIHJldHVybiBcIk5vIGZpbGVzIHRvIGNvbW1pdFwiO1xuXG4gICAgaWYgKHNlbGYuZmlsZXMoKS5zb21lKGZ1bmN0aW9uKGZpbGUpIHsgcmV0dXJuIGZpbGUuY29uZmxpY3QoKTsgfSkpXG4gICAgICByZXR1cm4gXCJGaWxlcyBpbiBjb25mbGljdFwiO1xuXG4gICAgaWYgKCFzZWxmLmNvbW1pdE1lc3NhZ2VUaXRsZSgpICYmICFzZWxmLmluUmViYXNlKCkpIHJldHVybiBcIlByb3ZpZGUgYSB0aXRsZVwiO1xuXG4gICAgaWYgKHNlbGYudGV4dERpZmZUeXBlKCkgPT09ICdzaWRlYnlzaWRlZGlmZicpIHtcbiAgICAgIHZhciBwYXRjaEZpbGVzID0gc2VsZi5maWxlcygpLmZpbHRlcihmdW5jdGlvbihmaWxlKSB7IHJldHVybiBmaWxlLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCc7IH0pO1xuICAgICAgaWYgKHBhdGNoRmlsZXMubGVuZ3RoID4gMCkgcmV0dXJuIFwiQ2Fubm90IHBhdGNoIHdpdGggc2lkZSBieSBzaWRlIHZpZXcuXCJcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIjtcbiAgfSk7XG4gIHRoaXMudG9nZ2xlU2VsZWN0QWxsR2x5cGhDbGFzcyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLmFsbFN0YWdlRmxhZygpKSByZXR1cm4gJ2dseXBoaWNvbi11bmNoZWNrZWQnO1xuICAgIGVsc2UgcmV0dXJuICdnbHlwaGljb24tY2hlY2snO1xuICB9KTtcblxuICB0aGlzLnJlZnJlc2hDb250ZW50VGhyb3R0bGVkID0gXy50aHJvdHRsZSh0aGlzLnJlZnJlc2hDb250ZW50LmJpbmQodGhpcyksIDQwMCwgeyB0cmFpbGluZzogdHJ1ZSB9KTtcbiAgdGhpcy5pbnZhbGlkYXRlRmlsZXNEaWZmc1Rocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy5pbnZhbGlkYXRlRmlsZXNEaWZmcy5iaW5kKHRoaXMpLCA0MDAsIHsgdHJhaWxpbmc6IHRydWUgfSk7XG4gIHRoaXMucmVmcmVzaENvbnRlbnRUaHJvdHRsZWQoKTtcbiAgdGhpcy50ZXh0RGlmZlR5cGUgPSBrby5vYnNlcnZhYmxlKCd0ZXh0ZGlmZicpO1xuICBpZiAod2luZG93LmxvY2F0aW9uLnNlYXJjaC5pbmRleE9mKCdub2hlYWRlcj10cnVlJykgPj0gMClcbiAgICB0aGlzLnJlZnJlc2hCdXR0b24gPSBjb21wb25lbnRzLmNyZWF0ZSgncmVmcmVzaGJ1dHRvbicpO1xuICB0aGlzLmxvYWRBbnl3YXkgPSBmYWxzZTtcbiAgdGhpcy5pc0RpYWdPcGVuID0gZmFsc2U7XG4gIHRoaXMubXV0ZWRUaW1lID0gbnVsbDtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCdzdGFnaW5nJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUub25Qcm9ncmFtRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQuZXZlbnQgPT0gJ3JlcXVlc3QtYXBwLWNvbnRlbnQtcmVmcmVzaCcpIHtcbiAgICB0aGlzLnJlZnJlc2hDb250ZW50KCk7XG4gICAgdGhpcy5pbnZhbGlkYXRlRmlsZXNEaWZmcygpO1xuICB9XG4gIGlmIChldmVudC5ldmVudCA9PSAnd29ya2luZy10cmVlLWNoYW5nZWQnKSB7XG4gICAgdGhpcy5yZWZyZXNoQ29udGVudFRocm90dGxlZCgpO1xuICAgIHRoaXMuaW52YWxpZGF0ZUZpbGVzRGlmZnNUaHJvdHRsZWQoKTtcbiAgfVxufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUucmVmcmVzaENvbnRlbnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyLmdldCgnL2hlYWQnLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbGltaXQ6IDEgfSwgZnVuY3Rpb24oZXJyLCBsb2cpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyLmVycm9yQ29kZSA9PSAnbXVzdC1iZS1pbi13b3JraW5nLXRyZWUnIHx8XG4gICAgICAgIGVyci5lcnJvckNvZGUgPT0gJ25vLXN1Y2gtcGF0aCc7XG4gICAgfVxuICAgIGlmIChsb2cubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGFycmF5ID0gbG9nWzBdLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgc2VsZi5IRUFEKHt0aXRsZTogYXJyYXlbMF0sIGJvZHk6IGFycmF5LnNsaWNlKDIpLmpvaW4oJ1xcbicpfSk7XG4gICAgfVxuICAgIGVsc2Ugc2VsZi5IRUFEKG51bGwpO1xuICB9KTtcbiAgdGhpcy5zZXJ2ZXIuZ2V0KCcvc3RhdHVzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGZpbGVMaW1pdDogZmlsZXNUb0Rpc3BsYXlMaW1pdCB9LCBmdW5jdGlvbihlcnIsIHN0YXR1cykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybiBlcnIuZXJyb3JDb2RlID09ICdtdXN0LWJlLWluLXdvcmtpbmctdHJlZScgfHxcbiAgICAgICAgZXJyLmVycm9yQ29kZSA9PSAnbm8tc3VjaC1wYXRoJztcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoc3RhdHVzLmZpbGVzKS5sZW5ndGggPiBmaWxlc1RvRGlzcGxheUxpbWl0ICYmICFzZWxmLmxvYWRBbnl3YXkpIHtcbiAgICAgIGlmIChzZWxmLmlzRGlhZ09wZW4pIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLmlzRGlhZ09wZW4gPSB0cnVlO1xuICAgICAgdmFyIGRpYWcgPSBjb21wb25lbnRzLmNyZWF0ZSgnVG9vTWFueUZpbGVzRGlhbG9nVmlld01vZGVsJywgeyB0aXRsZTogJ1RvbyBtYW55IHVuc3RhZ2VkIGZpbGVzJywgZGV0YWlsczogJ0l0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBjb21tYW5kIGxpbmUgYXMgdW5naXQgbWF5IGJlIHRvbyBzbG93Lid9KTtcblxuICAgICAgZGlhZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmlzRGlhZ09wZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgICAgICBzZWxmLmxvYWRBbnl3YXkgPSB0cnVlO1xuICAgICAgICAgIHNlbGYubG9hZFN0YXR1cyhzdGF0dXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcvIy8nO1xuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LXNob3ctZGlhbG9nJywgZGlhbG9nOiBkaWFnIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmxvYWRTdGF0dXMoc3RhdHVzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9KTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLmxvYWRTdGF0dXMgPSBmdW5jdGlvbihzdGF0dXMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuc2V0RmlsZXMoc3RhdHVzLmZpbGVzKTtcbiAgdGhpcy5pblJlYmFzZSghIXN0YXR1cy5pblJlYmFzZSk7XG4gIHRoaXMuaW5NZXJnZSghIXN0YXR1cy5pbk1lcmdlKTtcbiAgLy8gVGhlcmUgYXJlIHRpbWUgd2hlcmUgJy5naXQvQ0hFUlJZX1BJQ0tfSEVBRCcgZmlsZSBpcyBjcmVhdGVkIGFuZCBubyBmaWxlcyBhcmUgaW4gY29uZmxpY3RzLlxuICAvLyBpbiBzdWNoIGNhc2VzIHdlIHNob3VsZCBpZ25vcmUgZXhjZXB0aW9uIGFzIG5vIGdvb2Qgd2F5IHRvIHJlc29sdmUgaXQuXG4gIHRoaXMuaW5DaGVycnkoISFzdGF0dXMuaW5DaGVycnkgJiYgISFzdGF0dXMuaW5Db25mbGljdCk7XG5cbiAgaWYgKHRoaXMuaW5SZWJhc2UoKSkge1xuICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCdSZWJhc2UgY29uZmxpY3QnKTtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCdDb21taXQgbWVzc2FnZXMgYXJlIG5vdCBhcHBsaWNhYmxlIVxcbijila/CsOKWocKw77yJ4pWv77i1IOKUu+KUgeKUuycpO1xuICB9IGVsc2UgaWYgKHRoaXMuaW5NZXJnZSgpIHx8IHRoaXMuaW5DaGVycnkoKSkge1xuICAgIHZhciBsaW5lcyA9IHN0YXR1cy5jb21taXRNZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZShsaW5lc1swXSk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlQm9keShsaW5lcy5zbGljZSgxKS5qb2luKCdcXG4nKSk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUuc2V0RmlsZXMgPSBmdW5jdGlvbihmaWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBuZXdGaWxlcyA9IFtdO1xuICBmb3IodmFyIGZpbGUgaW4gZmlsZXMpIHtcbiAgICB2YXIgZmlsZVZpZXdNb2RlbCA9IHRoaXMuZmlsZXNCeVBhdGhbZmlsZV07XG4gICAgaWYgKCFmaWxlVmlld01vZGVsKSB7XG4gICAgICB0aGlzLmZpbGVzQnlQYXRoW2ZpbGVdID0gZmlsZVZpZXdNb2RlbCA9IG5ldyBGaWxlVmlld01vZGVsKHNlbGYsIGZpbGUsIHNlbGYudGV4dERpZmZUeXBlLCBzZWxmLndvcmRXcmFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhpcyBpcyBtYWlubHkgZm9yIHBhdGNoaW5nIGFuZCBpdCBtYXkgbm90IGZpcmUgZHVlIHRvIHRoZSBmYWN0IHRoYXRcbiAgICAgIC8vICcvY29tbWl0JyB0cmlnZ2VycyB3b3JraW5nLXRyZWUtY2hhbmdlZCB3aGljaCB0cmlnZ2VycyB0aHJvdHRsZWQgcmVmcmVzaFxuICAgICAgZmlsZVZpZXdNb2RlbC5pbnZhbGlkYXRlRGlmZigpO1xuICAgIH1cbiAgICBmaWxlVmlld01vZGVsLnNldFN0YXRlKGZpbGVzW2ZpbGVdKTtcbiAgICBuZXdGaWxlcy5wdXNoKGZpbGVWaWV3TW9kZWwpO1xuICB9XG4gIHRoaXMuZmlsZXMobmV3RmlsZXMpO1xuICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdpbml0LXRvb2x0aXAnIH0pO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlQW1lbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmFtZW5kKCkgJiYgIXRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkpIHtcbiAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSh0aGlzLkhFQUQoKS50aXRsZSk7XG4gICAgdGhpcy5jb21taXRNZXNzYWdlQm9keSh0aGlzLkhFQUQoKS5ib2R5KTtcbiAgfVxuICBlbHNlIGlmKHRoaXMuYW1lbmQoKSkge1xuICAgIHZhciBpc1ByZXZEZWZhdWx0TXNnID1cbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkgPT0gdGhpcy5IRUFEKCkudGl0bGUgJiZcbiAgICAgIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSA9PSB0aGlzLkhFQUQoKS5ib2R5O1xuICAgIGlmIChpc1ByZXZEZWZhdWx0TXNnKSB7XG4gICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VUaXRsZSgnJyk7XG4gICAgICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCcnKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5hbWVuZCghdGhpcy5hbWVuZCgpKTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnJlc2V0TWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoJycpO1xuICB0aGlzLmNvbW1pdE1lc3NhZ2VCb2R5KCcnKTtcbiAgdGhpcy5hbWVuZChmYWxzZSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmNvbW1pdHRpbmdQcm9ncmVzc0Jhci5zdGFydCgpO1xuICB2YXIgZmlsZXMgPSB0aGlzLmZpbGVzKCkuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcbiAgICByZXR1cm4gZmlsZS5lZGl0U3RhdGUoKSAhPT0gJ25vbmUnO1xuICB9KS5tYXAoZnVuY3Rpb24oZmlsZSkge1xuICAgIHJldHVybiB7IG5hbWU6IGZpbGUubmFtZSgpLCBwYXRjaExpbmVMaXN0OiBmaWxlLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCcgPyBmaWxlLnBhdGNoTGluZUxpc3QoKSA6IG51bGwgfTtcbiAgfSk7XG4gIHZhciBjb21taXRNZXNzYWdlID0gdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKTtcbiAgaWYgKHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSkgY29tbWl0TWVzc2FnZSArPSAnXFxuXFxuJyArIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKTtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL2NvbW1pdCcsIHsgcGF0aDogdGhpcy5yZXBvUGF0aCgpLCBtZXNzYWdlOiBjb21taXRNZXNzYWdlLCBmaWxlczogZmlsZXMsIGFtZW5kOiB0aGlzLmFtZW5kKCkgfSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBzZWxmLmNvbW1pdHRpbmdQcm9ncmVzc0Jhci5zdG9wKCk7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnJlc2V0TWVzc2FnZXMoKTtcbiAgICBzZWxmLmZpbGVzKFtdKTtcbiAgfSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5jb25mbGljdFJlc29sdXRpb24gPSBmdW5jdGlvbihhcGlQYXRoLCBwcm9ncmVzc0Jhcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHByb2dyZXNzQmFyLnN0YXJ0KCk7XG4gIHZhciBjb21taXRNZXNzYWdlID0gdGhpcy5jb21taXRNZXNzYWdlVGl0bGUoKTtcbiAgaWYgKHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKSkgY29tbWl0TWVzc2FnZSArPSAnXFxuXFxuJyArIHRoaXMuY29tbWl0TWVzc2FnZUJvZHkoKTtcbiAgdGhpcy5zZXJ2ZXIucG9zdChhcGlQYXRoLCB7IHBhdGg6IHRoaXMucmVwb1BhdGgoKSwgbWVzc2FnZTogY29tbWl0TWVzc2FnZSB9LCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgIHNlbGYucmVzZXRNZXNzYWdlcygpO1xuICAgIHByb2dyZXNzQmFyLnN0b3AoKTtcbiAgfSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5pbnZhbGlkYXRlRmlsZXNEaWZmcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZpbGVzKCkuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XG4gICAgZmlsZS5kaWZmKCkuaW52YWxpZGF0ZURpZmYoKTtcbiAgfSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5kaXNjYXJkQWxsQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBkaWFnID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkaXNjYXJkIGFsbCBjaGFuZ2VzPycsIGRldGFpbHM6ICdUaGlzIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lLid9KTtcbiAgZGlhZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChkaWFnLnJlc3VsdCgpKSBzZWxmLnNlcnZlci5wb3N0KCcvZGlzY2FyZGNoYW5nZXMnLCB7IHBhdGg6IHNlbGYucmVwb1BhdGgoKSwgYWxsOiB0cnVlIH0pO1xuICB9KTtcbiAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZGlhZyB9KTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnN0YXNoQWxsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zdGFzaFByb2dyZXNzQmFyLnN0YXJ0KCk7XG4gIHRoaXMuc2VydmVyLnBvc3QoJy9zdGFzaGVzJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIG1lc3NhZ2U6IHRoaXMuY29tbWl0TWVzc2FnZVRpdGxlKCkgfSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICBzZWxmLnN0YXNoUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICB9KTtcbn1cblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZUFsbFN0YWdlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZvciAodmFyIG4gaW4gc2VsZi5maWxlcygpKXtcbiAgICBzZWxmLmZpbGVzKClbbl0uZWRpdFN0YXRlKHNlbGYuYWxsU3RhZ2VGbGFnKCkgPyAnc3RhZ2VkJyA6ICdub25lJyk7XG4gIH1cblxuICBzZWxmLmFsbFN0YWdlRmxhZyghc2VsZi5hbGxTdGFnZUZsYWcoKSk7XG59XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS50ZXh0RGlmZlR5cGVDaGFuZ2UgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHRoaXMudGV4dERpZmZUeXBlKHR5cGUpO1xufVxuU3RhZ2luZ1ZpZXdNb2RlbC5wcm90b3R5cGUub25FbnRlciA9IGZ1bmN0aW9uKGQsIGUpe1xuICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmICF0aGlzLmNvbW1pdFZhbGlkYXRpb25FcnJvcigpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5TdGFnaW5nVmlld01vZGVsLnByb3RvdHlwZS5vbkFsdEVudGVyID0gZnVuY3Rpb24oZCwgZSl7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMTMgJiYgZS5hbHRLZXkgJiYgIXRoaXMuY29tbWl0VmFsaWRhdGlvbkVycm9yKCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblN0YWdpbmdWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZVdvcmRXcmFwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy53b3JkV3JhcChzdGF0ZSk7XG59O1xuXG52YXIgRmlsZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKHN0YWdpbmcsIG5hbWUsIHRleHREaWZmVHlwZSwgd29yZFdyYXApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnN0YWdpbmcgPSBzdGFnaW5nO1xuICB0aGlzLnNlcnZlciA9IHN0YWdpbmcuc2VydmVyO1xuICB0aGlzLmVkaXRTdGF0ZSA9IGtvLm9ic2VydmFibGUoJ3N0YWdlZCcpOyAvLyBzdGFnZWQsIHBhdGNoZWQgYW5kIG5vbmVcbiAgdGhpcy5uYW1lID0ga28ub2JzZXJ2YWJsZShuYW1lKTtcbiAgdGhpcy5kaXNwbGF5TmFtZSA9IGtvLm9ic2VydmFibGUobmFtZSk7XG4gIHRoaXMuaXNOZXcgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5yZW1vdmVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY29uZmxpY3QgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5yZW5hbWVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuaXNTaG93aW5nRGlmZnMgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5kaWZmUHJvZ3Jlc3NCYXIgPSBjb21wb25lbnRzLmNyZWF0ZSgncHJvZ3Jlc3NCYXInLCB7IHByZWRpY3Rpb25NZW1vcnlLZXk6ICdkaWZmcy0nICsgdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIHRlbXBvcmFyeTogdHJ1ZSB9KTtcbiAgdGhpcy5pc1Nob3dpbmdEaWZmcyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLnRleHREaWZmVHlwZSA9IHRleHREaWZmVHlwZTtcbiAgdGhpcy53b3JkV3JhcCA9IHdvcmRXcmFwO1xuICB0aGlzLmFkZGl0aW9ucyA9IGtvLm9ic2VydmFibGUoJycpO1xuICB0aGlzLmRlbGV0aW9ucyA9IGtvLm9ic2VydmFibGUoJycpO1xuICB0aGlzLmZpbGVUeXBlID0ga28ub2JzZXJ2YWJsZSgndGV4dCcpO1xuICB0aGlzLnBhdGNoTGluZUxpc3QgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcbiAgdGhpcy5kaWZmID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmlzU2hvd1BhdGNoID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgLy8gaWYgbm90IG5ldyBmaWxlXG4gICAgLy8gYW5kIGlmIG5vdCBtZXJnaW5nXG4gICAgLy8gYW5kIGlmIG5vdCByZWJhc2luZ1xuICAgIC8vIGFuZCBpZiB0ZXh0IGZpbGVcbiAgICAvLyBhbmQgaWYgZGlmZiBpcyBzaG93aW5nLCBkaXNwbGF5IHBhdGNoIGJ1dHRvblxuICAgIHJldHVybiAhc2VsZi5pc05ldygpICYmICFzdGFnaW5nLmluTWVyZ2UoKSAmJiAhc3RhZ2luZy5pblJlYmFzZSgpICYmIHNlbGYuZmlsZVR5cGUoKSA9PT0gJ3RleHQnICYmIHNlbGYuaXNTaG93aW5nRGlmZnMoKTtcbiAgfSk7XG5cbiAgdGhpcy5lZGl0U3RhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICBzZWxmLnBhdGNoTGluZUxpc3QoW10pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdwYXRjaGVkJykge1xuICAgICAgaWYgKHNlbGYuZGlmZigpLnJlbmRlcikgc2VsZi5kaWZmKCkucmVuZGVyKCk7XG4gICAgfVxuICB9KTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLmdldFNwZWNpZmljRGlmZiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29tcG9uZW50cy5jcmVhdGUoIXRoaXMubmFtZSgpIHx8IHRoaXMuZmlsZVR5cGUoKSArICdkaWZmJywge1xuICAgIGZpbGVuYW1lOiB0aGlzLm5hbWUoKSxcbiAgICByZXBvUGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoLFxuICAgIHNlcnZlcjogdGhpcy5zZXJ2ZXIsXG4gICAgdGV4dERpZmZUeXBlOiB0aGlzLnRleHREaWZmVHlwZSxcbiAgICBpc1Nob3dpbmdEaWZmczogdGhpcy5pc1Nob3dpbmdEaWZmcyxcbiAgICBkaWZmUHJvZ3Jlc3NCYXI6IHRoaXMuZGlmZlByb2dyZXNzQmFyLFxuICAgIHBhdGNoTGluZUxpc3Q6IHRoaXMucGF0Y2hMaW5lTGlzdCxcbiAgICBlZGl0U3RhdGU6IHRoaXMuZWRpdFN0YXRlLFxuICAgIHdvcmRXcmFwOiB0aGlzLndvcmRXcmFwXG4gIH0pO1xufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLmRpc3BsYXlOYW1lKHN0YXRlLmRpc3BsYXlOYW1lKTtcbiAgdGhpcy5pc05ldyhzdGF0ZS5pc05ldyk7XG4gIHRoaXMucmVtb3ZlZChzdGF0ZS5yZW1vdmVkKTtcbiAgdGhpcy5jb25mbGljdChzdGF0ZS5jb25mbGljdCk7XG4gIHRoaXMucmVuYW1lZChzdGF0ZS5yZW5hbWVkKTtcbiAgdGhpcy5maWxlVHlwZShzdGF0ZS50eXBlKTtcbiAgdGhpcy5hZGRpdGlvbnMoc3RhdGUuYWRkaXRpb25zICE9ICctJyA/ICcrJyArIHN0YXRlLmFkZGl0aW9ucyA6ICcnKTtcbiAgdGhpcy5kZWxldGlvbnMoc3RhdGUuZGVsZXRpb25zICE9ICctJyA/ICctJyArIHN0YXRlLmRlbGV0aW9ucyA6ICcnKTtcbiAgdGhpcy5kaWZmID0ga28ub2JzZXJ2YWJsZSh0aGlzLmdldFNwZWNpZmljRGlmZigpKTtcbiAgaWYgKHRoaXMuZGlmZigpLmlzTmV3KSB0aGlzLmRpZmYoKS5pc05ldyhzdGF0ZS5pc05ldyk7XG4gIGlmICh0aGlzLmRpZmYoKS5pc1JlbW92ZWQpIHRoaXMuZGlmZigpLmlzUmVtb3ZlZChzdGF0ZS5yZW1vdmVkKTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLnRvZ2dsZVN0YWdlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5lZGl0U3RhdGUoKSA9PT0gJ25vbmUnKSB7XG4gICAgdGhpcy5lZGl0U3RhdGUoJ3N0YWdlZCcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZWRpdFN0YXRlKCdub25lJyk7XG4gIH1cbiAgdGhpcy5wYXRjaExpbmVMaXN0KFtdKTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLmRpc2NhcmRDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHVuZ2l0LmNvbmZpZy5kaXNhYmxlRGlzY2FyZFdhcm5pbmcgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YWdpbmcubXV0ZWRUaW1lIDwgdW5naXQuY29uZmlnLmRpc2FibGVEaXNjYXJkTXV0ZVRpbWUpIHtcbiAgICBzZWxmLnNlcnZlci5wb3N0KCcvZGlzY2FyZGNoYW5nZXMnLCB7IHBhdGg6IHNlbGYuc3RhZ2luZy5yZXBvUGF0aCgpLCBmaWxlOiBzZWxmLm5hbWUoKSB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlhZyA9IGNvbXBvbmVudHMuY3JlYXRlKCd5ZXNub211dGVkaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRpc2NhcmQgdGhlc2UgY2hhbmdlcz8nLCBkZXRhaWxzOiAnVGhpcyBvcGVyYXRpb24gY2Fubm90IGJlIHVuZG9uZS4nfSk7XG4gICAgZGlhZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRpYWcucmVzdWx0KCkpIHNlbGYuc2VydmVyLnBvc3QoJy9kaXNjYXJkY2hhbmdlcycsIHsgcGF0aDogc2VsZi5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGU6IHNlbGYubmFtZSgpIH0pO1xuICAgICAgaWYgKGRpYWcucmVzdWx0KCkgPT09IFwibXV0ZVwiKSBzZWxmLnN0YWdpbmcubXV0ZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfSk7XG4gICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZGlhZyB9KTtcbiAgfVxufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUuaWdub3JlRmlsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyLnBvc3QoJy9pZ25vcmVmaWxlJywgeyBwYXRoOiB0aGlzLnN0YWdpbmcucmVwb1BhdGgoKSwgZmlsZTogdGhpcy5uYW1lKCkgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuZXJyb3JDb2RlID09ICdmaWxlLWFscmVhZHktZ2l0LWlnbm9yZWQnKSB7XG4gICAgICAvLyBUaGUgZmlsZSB3YXMgYWxyZWFkeSBpbiB0aGUgLmdpdGlnbm9yZSwgc28gZm9yY2UgYW4gdXBkYXRlIG9mIHRoZSBzdGFnaW5nIGFyZWEgKHRvIGhvcGVmdWxsIGNsZWFyIGF3YXkgdGhpcyBmaWxlKVxuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnd29ya2luZy10cmVlLWNoYW5nZWQnIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbn1cbkZpbGVWaWV3TW9kZWwucHJvdG90eXBlLnJlc29sdmVDb25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcnZlci5wb3N0KCcvcmVzb2x2ZWNvbmZsaWN0cycsIHsgcGF0aDogdGhpcy5zdGFnaW5nLnJlcG9QYXRoKCksIGZpbGVzOiBbdGhpcy5uYW1lKCldIH0pO1xufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlRGlmZnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVuYW1lZCgpKSByZXR1cm47IC8vIGRvIG5vdCBzaG93IGRpZmZzIGZvciByZW5hbWVzXG4gIGlmICh0aGlzLmlzU2hvd2luZ0RpZmZzKCkpIHtcbiAgICB0aGlzLmlzU2hvd2luZ0RpZmZzKGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzU2hvd2luZ0RpZmZzKHRydWUpO1xuICAgIHRoaXMuaW52YWxpZGF0ZURpZmYoKTtcbiAgfVxufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUucGF0Y2hDbGljayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNTaG93aW5nRGlmZnMoKSkgcmV0dXJuO1xuXG4gIGlmICh0aGlzLmVkaXRTdGF0ZSgpID09PSAncGF0Y2hlZCcpIHtcbiAgICB0aGlzLmVkaXRTdGF0ZSgnc3RhZ2VkJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lZGl0U3RhdGUoJ3BhdGNoZWQnKTtcbiAgfVxufVxuRmlsZVZpZXdNb2RlbC5wcm90b3R5cGUuaW52YWxpZGF0ZURpZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kaWZmKCkuaW52YWxpZGF0ZURpZmYoKTtcbn1cbiJdfQ==
