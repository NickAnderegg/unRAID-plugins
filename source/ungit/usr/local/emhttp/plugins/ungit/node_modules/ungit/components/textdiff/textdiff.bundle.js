(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

var ko = require('knockout');
var components = require('ungit-components');
var diff2html = require('diff2html').Diff2Html;

components.register('textdiff', function(args) {
  return new TextDiffViewModel(args);
});

var loadLimit = 100;

var TextDiffViewModel = function(args) {
  var self = this;
  this.filename = args.filename;
  this.repoPath = args.repoPath;
  this.server = args.server;
  this.sha1 = args.sha1;
  this.loadMoreCount = ko.observable(0);
  this.diffJson = null;
  this.loadCount = loadLimit;
  this.textDiffType = args.textDiffType;
  this.isShowingDiffs = args.isShowingDiffs;
  this.diffProgressBar = args.diffProgressBar;
  this.editState = args.editState;
  this.wordWrap = args.wordWrap;

  this.textDiffType.subscribe(function() {
    self.invalidateDiff();
  });
  this.patchLineList = args.patchLineList;
  this.numberOfSelectedPatchLines = 0;
  this.htmlSrc = undefined;
  this.isParsed = ko.observable(false);
}
TextDiffViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('textdiff', this, {}, parentElement);
}
TextDiffViewModel.prototype.getDiffArguments = function() {
  return {
    file: this.filename,
    path: this.repoPath(),
    sha1: this.sha1 ? this.sha1 : ''
  };
}

TextDiffViewModel.prototype.invalidateDiff = function(callback) {
  var self = this;
  if (this.isShowingDiffs()) {
    if (this.diffProgressBar) this.diffProgressBar.start();

    self.server.get('/diff', this.getDiffArguments() , function(err, diffs) {
      if (err) {
        if (self.diffProgressBar) self.diffProgressBar.stop();
        if (err.errorCode == 'no-such-file') {
          // The file existed before but has been removed, but we're trying to get a diff for it
          // Most likely it will just disappear with the next refresh of the staging area
          // so we just ignore the error here
          return true;
        }
        return callback ? callback(err) : null;
      }

      if (typeof diffs == 'string') {
        self.diffJson = diff2html.getJsonFromDiff(diffs);
        self.render();
      }

      if (self.diffProgressBar) self.diffProgressBar.stop();
      if (callback) callback();
    });
  } else {
    if (callback) callback();
  }
}

TextDiffViewModel.prototype.render = function() {
  if (this.diffJson.length == 0) return; // check if diffs are available (binary files do not support them)
  this.isParsed(false);

  var self = this;
  var diffJsonCopy = JSON.parse(JSON.stringify(this.diffJson)); // make a json copy
  var lineCount = 0;

  diffJsonCopy[0].blocks = diffJsonCopy[0].blocks.reduce(function(blocks, block) {
    var length = block.lines.length;
    if (lineCount < self.loadCount) {
      block.lines = block.lines.slice(0, self.loadCount - lineCount);
      blocks.push(block);
    }
    lineCount += length;
    return blocks;
  }, []);

  this.loadMoreCount(Math.min(loadLimit, Math.max(0, lineCount - this.loadCount)));

  var html;

  if (this.textDiffType() === 'sidebysidediff') {
    html = diff2html.getPrettySideBySideHtmlFromJson(diffJsonCopy);
  } else {
    html = diff2html.getPrettyHtmlFromJson(diffJsonCopy);
  }

  var index = 0;
  this.numberOfSelectedPatchLines = 0;

  // if self.patchLineList is null then patching is not avaliable so skip this expensive op.x
  if (self.patchLineList) {
    html = html.replace(/<span class="d2h-code-line-[a-z]+">(\+|\-)/g, function (match, capture) {
      if (self.patchLineList()[index] === undefined) {
        self.patchLineList()[index] = true;
      }

      return self.getPatchCheckBox(capture, index, self.patchLineList()[index++]);
    });
  }

  // ko's binding resolution is not recursive, which means below ko.bind refresh method doesn't work for
  // data bind at getPatchCheckBox that is rendered with "html" binding.
  // which is reason why manually updating the html content and refreshing kobinding to have it render...
  this.htmlSrc = html;
  this.isParsed(true);
};

TextDiffViewModel.prototype.loadMore = function(callback) {
  this.loadCount += this.loadMoreCount();
  this.render();
}

TextDiffViewModel.prototype.getPatchCheckBox = function(symbol, index, isActive) {
  if (isActive) {
    this.numberOfSelectedPatchLines++;
  }
  return '<div class="d2h-code-line-prefix"><span data-bind="visible: editState() !== \'patched\'">' + symbol + '</span><input ' + (isActive ? 'checked' : '') + ' type="checkbox" data-ta-clickable="patch-line-input" data-bind="visible: editState() === \'patched\', click: togglePatchLine.bind($data, ' + index + ')"></input>';
}

TextDiffViewModel.prototype.togglePatchLine = function(index) {
  this.patchLineList()[index] = !this.patchLineList()[index];

  if (this.patchLineList()[index]) {
    this.numberOfSelectedPatchLines++;
  } else {
    this.numberOfSelectedPatchLines--;
  }

  if (this.numberOfSelectedPatchLines === 0) {
    this.editState('none');
  }

  return true;
}

},{"diff2html":undefined,"knockout":"knockout","ungit-components":"ungit-components"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL3RleHRkaWZmL3RleHRkaWZmLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBkaWZmMmh0bWwgPSByZXF1aXJlKCdkaWZmMmh0bWwnKS5EaWZmMkh0bWw7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ3RleHRkaWZmJywgZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gbmV3IFRleHREaWZmVmlld01vZGVsKGFyZ3MpO1xufSk7XG5cbnZhciBsb2FkTGltaXQgPSAxMDA7XG5cbnZhciBUZXh0RGlmZlZpZXdNb2RlbCA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmZpbGVuYW1lID0gYXJncy5maWxlbmFtZTtcbiAgdGhpcy5yZXBvUGF0aCA9IGFyZ3MucmVwb1BhdGg7XG4gIHRoaXMuc2VydmVyID0gYXJncy5zZXJ2ZXI7XG4gIHRoaXMuc2hhMSA9IGFyZ3Muc2hhMTtcbiAgdGhpcy5sb2FkTW9yZUNvdW50ID0ga28ub2JzZXJ2YWJsZSgwKTtcbiAgdGhpcy5kaWZmSnNvbiA9IG51bGw7XG4gIHRoaXMubG9hZENvdW50ID0gbG9hZExpbWl0O1xuICB0aGlzLnRleHREaWZmVHlwZSA9IGFyZ3MudGV4dERpZmZUeXBlO1xuICB0aGlzLmlzU2hvd2luZ0RpZmZzID0gYXJncy5pc1Nob3dpbmdEaWZmcztcbiAgdGhpcy5kaWZmUHJvZ3Jlc3NCYXIgPSBhcmdzLmRpZmZQcm9ncmVzc0JhcjtcbiAgdGhpcy5lZGl0U3RhdGUgPSBhcmdzLmVkaXRTdGF0ZTtcbiAgdGhpcy53b3JkV3JhcCA9IGFyZ3Mud29yZFdyYXA7XG5cbiAgdGhpcy50ZXh0RGlmZlR5cGUuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuaW52YWxpZGF0ZURpZmYoKTtcbiAgfSk7XG4gIHRoaXMucGF0Y2hMaW5lTGlzdCA9IGFyZ3MucGF0Y2hMaW5lTGlzdDtcbiAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcyA9IDA7XG4gIHRoaXMuaHRtbFNyYyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc1BhcnNlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xufVxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLnVwZGF0ZU5vZGUgPSBmdW5jdGlvbihwYXJlbnRFbGVtZW50KSB7XG4gIGtvLnJlbmRlclRlbXBsYXRlKCd0ZXh0ZGlmZicsIHRoaXMsIHt9LCBwYXJlbnRFbGVtZW50KTtcbn1cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5nZXREaWZmQXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZmlsZTogdGhpcy5maWxlbmFtZSxcbiAgICBwYXRoOiB0aGlzLnJlcG9QYXRoKCksXG4gICAgc2hhMTogdGhpcy5zaGExID8gdGhpcy5zaGExIDogJydcbiAgfTtcbn1cblxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLmludmFsaWRhdGVEaWZmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5pc1Nob3dpbmdEaWZmcygpKSB7XG4gICAgaWYgKHRoaXMuZGlmZlByb2dyZXNzQmFyKSB0aGlzLmRpZmZQcm9ncmVzc0Jhci5zdGFydCgpO1xuXG4gICAgc2VsZi5zZXJ2ZXIuZ2V0KCcvZGlmZicsIHRoaXMuZ2V0RGlmZkFyZ3VtZW50cygpICwgZnVuY3Rpb24oZXJyLCBkaWZmcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoc2VsZi5kaWZmUHJvZ3Jlc3NCYXIpIHNlbGYuZGlmZlByb2dyZXNzQmFyLnN0b3AoKTtcbiAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT0gJ25vLXN1Y2gtZmlsZScpIHtcbiAgICAgICAgICAvLyBUaGUgZmlsZSBleGlzdGVkIGJlZm9yZSBidXQgaGFzIGJlZW4gcmVtb3ZlZCwgYnV0IHdlJ3JlIHRyeWluZyB0byBnZXQgYSBkaWZmIGZvciBpdFxuICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IGl0IHdpbGwganVzdCBkaXNhcHBlYXIgd2l0aCB0aGUgbmV4dCByZWZyZXNoIG9mIHRoZSBzdGFnaW5nIGFyZWFcbiAgICAgICAgICAvLyBzbyB3ZSBqdXN0IGlnbm9yZSB0aGUgZXJyb3IgaGVyZVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKGVycikgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRpZmZzID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlbGYuZGlmZkpzb24gPSBkaWZmMmh0bWwuZ2V0SnNvbkZyb21EaWZmKGRpZmZzKTtcbiAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuZGlmZlByb2dyZXNzQmFyKSBzZWxmLmRpZmZQcm9ncmVzc0Jhci5zdG9wKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICB9XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGlmZkpzb24ubGVuZ3RoID09IDApIHJldHVybjsgLy8gY2hlY2sgaWYgZGlmZnMgYXJlIGF2YWlsYWJsZSAoYmluYXJ5IGZpbGVzIGRvIG5vdCBzdXBwb3J0IHRoZW0pXG4gIHRoaXMuaXNQYXJzZWQoZmFsc2UpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRpZmZKc29uQ29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5kaWZmSnNvbikpOyAvLyBtYWtlIGEganNvbiBjb3B5XG4gIHZhciBsaW5lQ291bnQgPSAwO1xuXG4gIGRpZmZKc29uQ29weVswXS5ibG9ja3MgPSBkaWZmSnNvbkNvcHlbMF0uYmxvY2tzLnJlZHVjZShmdW5jdGlvbihibG9ja3MsIGJsb2NrKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJsb2NrLmxpbmVzLmxlbmd0aDtcbiAgICBpZiAobGluZUNvdW50IDwgc2VsZi5sb2FkQ291bnQpIHtcbiAgICAgIGJsb2NrLmxpbmVzID0gYmxvY2subGluZXMuc2xpY2UoMCwgc2VsZi5sb2FkQ291bnQgLSBsaW5lQ291bnQpO1xuICAgICAgYmxvY2tzLnB1c2goYmxvY2spO1xuICAgIH1cbiAgICBsaW5lQ291bnQgKz0gbGVuZ3RoO1xuICAgIHJldHVybiBibG9ja3M7XG4gIH0sIFtdKTtcblxuICB0aGlzLmxvYWRNb3JlQ291bnQoTWF0aC5taW4obG9hZExpbWl0LCBNYXRoLm1heCgwLCBsaW5lQ291bnQgLSB0aGlzLmxvYWRDb3VudCkpKTtcblxuICB2YXIgaHRtbDtcblxuICBpZiAodGhpcy50ZXh0RGlmZlR5cGUoKSA9PT0gJ3NpZGVieXNpZGVkaWZmJykge1xuICAgIGh0bWwgPSBkaWZmMmh0bWwuZ2V0UHJldHR5U2lkZUJ5U2lkZUh0bWxGcm9tSnNvbihkaWZmSnNvbkNvcHkpO1xuICB9IGVsc2Uge1xuICAgIGh0bWwgPSBkaWZmMmh0bWwuZ2V0UHJldHR5SHRtbEZyb21Kc29uKGRpZmZKc29uQ29weSk7XG4gIH1cblxuICB2YXIgaW5kZXggPSAwO1xuICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzID0gMDtcblxuICAvLyBpZiBzZWxmLnBhdGNoTGluZUxpc3QgaXMgbnVsbCB0aGVuIHBhdGNoaW5nIGlzIG5vdCBhdmFsaWFibGUgc28gc2tpcCB0aGlzIGV4cGVuc2l2ZSBvcC54XG4gIGlmIChzZWxmLnBhdGNoTGluZUxpc3QpIHtcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKC88c3BhbiBjbGFzcz1cImQyaC1jb2RlLWxpbmUtW2Etel0rXCI+KFxcK3xcXC0pL2csIGZ1bmN0aW9uIChtYXRjaCwgY2FwdHVyZSkge1xuICAgICAgaWYgKHNlbGYucGF0Y2hMaW5lTGlzdCgpW2luZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYucGF0Y2hMaW5lTGlzdCgpW2luZGV4XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmdldFBhdGNoQ2hlY2tCb3goY2FwdHVyZSwgaW5kZXgsIHNlbGYucGF0Y2hMaW5lTGlzdCgpW2luZGV4KytdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGtvJ3MgYmluZGluZyByZXNvbHV0aW9uIGlzIG5vdCByZWN1cnNpdmUsIHdoaWNoIG1lYW5zIGJlbG93IGtvLmJpbmQgcmVmcmVzaCBtZXRob2QgZG9lc24ndCB3b3JrIGZvclxuICAvLyBkYXRhIGJpbmQgYXQgZ2V0UGF0Y2hDaGVja0JveCB0aGF0IGlzIHJlbmRlcmVkIHdpdGggXCJodG1sXCIgYmluZGluZy5cbiAgLy8gd2hpY2ggaXMgcmVhc29uIHdoeSBtYW51YWxseSB1cGRhdGluZyB0aGUgaHRtbCBjb250ZW50IGFuZCByZWZyZXNoaW5nIGtvYmluZGluZyB0byBoYXZlIGl0IHJlbmRlci4uLlxuICB0aGlzLmh0bWxTcmMgPSBodG1sO1xuICB0aGlzLmlzUGFyc2VkKHRydWUpO1xufTtcblxuVGV4dERpZmZWaWV3TW9kZWwucHJvdG90eXBlLmxvYWRNb3JlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5sb2FkQ291bnQgKz0gdGhpcy5sb2FkTW9yZUNvdW50KCk7XG4gIHRoaXMucmVuZGVyKCk7XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS5nZXRQYXRjaENoZWNrQm94ID0gZnVuY3Rpb24oc3ltYm9sLCBpbmRleCwgaXNBY3RpdmUpIHtcbiAgaWYgKGlzQWN0aXZlKSB7XG4gICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcysrO1xuICB9XG4gIHJldHVybiAnPGRpdiBjbGFzcz1cImQyaC1jb2RlLWxpbmUtcHJlZml4XCI+PHNwYW4gZGF0YS1iaW5kPVwidmlzaWJsZTogZWRpdFN0YXRlKCkgIT09IFxcJ3BhdGNoZWRcXCdcIj4nICsgc3ltYm9sICsgJzwvc3Bhbj48aW5wdXQgJyArIChpc0FjdGl2ZSA/ICdjaGVja2VkJyA6ICcnKSArICcgdHlwZT1cImNoZWNrYm94XCIgZGF0YS10YS1jbGlja2FibGU9XCJwYXRjaC1saW5lLWlucHV0XCIgZGF0YS1iaW5kPVwidmlzaWJsZTogZWRpdFN0YXRlKCkgPT09IFxcJ3BhdGNoZWRcXCcsIGNsaWNrOiB0b2dnbGVQYXRjaExpbmUuYmluZCgkZGF0YSwgJyArIGluZGV4ICsgJylcIj48L2lucHV0Pic7XG59XG5cblRleHREaWZmVmlld01vZGVsLnByb3RvdHlwZS50b2dnbGVQYXRjaExpbmUgPSBmdW5jdGlvbihpbmRleCkge1xuICB0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0gPSAhdGhpcy5wYXRjaExpbmVMaXN0KClbaW5kZXhdO1xuXG4gIGlmICh0aGlzLnBhdGNoTGluZUxpc3QoKVtpbmRleF0pIHtcbiAgICB0aGlzLm51bWJlck9mU2VsZWN0ZWRQYXRjaExpbmVzKys7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5udW1iZXJPZlNlbGVjdGVkUGF0Y2hMaW5lcy0tO1xuICB9XG5cbiAgaWYgKHRoaXMubnVtYmVyT2ZTZWxlY3RlZFBhdGNoTGluZXMgPT09IDApIHtcbiAgICB0aGlzLmVkaXRTdGF0ZSgnbm9uZScpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=
