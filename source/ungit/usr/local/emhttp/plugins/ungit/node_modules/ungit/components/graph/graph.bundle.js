(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ko = require('knockout');
require('mina');

module.exports = function(graph) {
  var self = this;
  this.element = ko.observable();
  this.previousGraph = undefined;
  this.element.subscribe(function(val) {
    if (val) self.animate(true);
  });
  this.animate = function(forceRefresh) {
    var currentGraph = this.getGraphAttr();
    // animate only when dom is valid and (attribute changed or force refresh due to dom change)
    if (this.element() && (forceRefresh || JSON.stringify(currentGraph) !== JSON.stringify(this.previousGraph))) {
      var now = Date.now();
      window.mina(this.previousGraph || currentGraph, currentGraph, now, now + 750, window.mina.time, function (val) {
        self.setGraphAttr(val);
      }, window.mina.elastic);
      this.previousGraph = currentGraph;
    }
  }
};

},{"knockout":"knockout","mina":undefined}],2:[function(require,module,exports){
var ko = require('knockout');
var Animateable = require('./animateable');

var EdgeViewModel = function(graph, nodeAsha1, nodeBsha1) {
  var self = this;
  Animateable.call(this);
  this.nodeA = graph.getNode(nodeAsha1);
  this.nodeB = graph.getNode(nodeBsha1);
  this.getGraphAttr = ko.computed(function() {
    if (self.nodeB.isInited && self.nodeB.cx() && self.nodeB.cy()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeB.cx(), self.nodeB.cy(), self.nodeB.cx(), self.nodeB.cy()];
    } else if (graph.graphHeight()) {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), graph.graphHeight(), self.nodeA.cx(), graph.graphHeight()];
    } else {
      return [self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy(),
              self.nodeA.cx(), self.nodeA.cy(), self.nodeA.cx(), self.nodeA.cy()];
    }
  });
  this.getGraphAttr.subscribe(this.animate.bind(this));
}
EdgeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('d', 'M' + val.slice(0,4).join(',') + 'L' + val.slice(4,8).join(','));
}
module.exports = EdgeViewModel;

},{"./animateable":1,"knockout":"knockout"}],3:[function(require,module,exports){

var ko = require('knockout');
var inherits = require('util').inherits;
var components = require('ungit-components');
var RefViewModel = require('./git-ref.js');
var HoverActions = require('./hover-actions');
var RebaseViewModel = HoverActions.RebaseViewModel;
var MergeViewModel = HoverActions.MergeViewModel;
var ResetViewModel = HoverActions.ResetViewModel;
var PushViewModel = HoverActions.PushViewModel;
var programEvents = require('ungit-program-events');

var GraphActions = {};
module.exports = GraphActions;

GraphActions.ActionBase = function(graph) {
  var self = this;
  this.graph = graph;
  this.server = graph.server;
  this.performProgressBar = components.create('progressBar', {
    predictionMemoryKey: 'action-' + this.style + '-' + graph.repoPath(),
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });

  this.isHighlighted = ko.computed(function() {
    return !graph.hoverGraphAction() || graph.hoverGraphAction() == self;
  });
  this.cssClasses = ko.computed(function() {
    var c = self.style;
    if (!self.isHighlighted()) c += ' dimmed';
    return c;
  })
}
GraphActions.ActionBase.prototype.icon = null;
GraphActions.ActionBase.prototype.doPerform = function() {
  var self = this;
  this.graph.hoverGraphAction(null);
  self.performProgressBar.start();
  this.perform(function() {
    self.performProgressBar.stop();
  });
}
GraphActions.ActionBase.prototype.dragEnter = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.dragLeave = function() {
  if (!this.visible()) return;
  this.graph.hoverGraphAction(null);
}
GraphActions.ActionBase.prototype.mouseover = function() {
  this.graph.hoverGraphAction(this);
}
GraphActions.ActionBase.prototype.mouseout = function() {
  this.graph.hoverGraphAction(null);
}

GraphActions.Move = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Move, GraphActions.ActionBase);
GraphActions.Move.prototype.text = 'Move';
GraphActions.Move.prototype.style = 'move';
GraphActions.Move.prototype.icon = 'glyphicon glyphicon-move';
GraphActions.Move.prototype.perform = function(callback) {
  this.graph.currentActionContext().moveTo(this.node.sha1, callback);
}

GraphActions.Reset = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!(self.graph.currentActionContext() instanceof RefViewModel)) return false;
    var context = self.graph.currentActionContext();
    if (context.node() != self.node) return false;
    var remoteRef = context.getRemoteRef(self.graph.currentRemote());
    return remoteRef &&
      remoteRef.node() != context.node() &&
      remoteRef.node().date < context.node().date;
  });
}
inherits(GraphActions.Reset, GraphActions.ActionBase);
GraphActions.Reset.prototype.text = 'Reset';
GraphActions.Reset.prototype.style = 'reset';
GraphActions.Reset.prototype.icon = 'glyphicon glyphicon-trash';
GraphActions.Reset.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  var nodes = context.node().getPathToCommonAncestor(remoteRef.node()).slice(0, -1);
  return new ResetViewModel(nodes);
}
GraphActions.Reset.prototype.perform = function(callback) {
  var self = this;
  var context = this.graph.currentActionContext();
  var remoteRef = context.getRemoteRef(self.graph.currentRemote());
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'Resetting to ref: ' + remoteRef.name + ' cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
      self.server.post('/reset', { path: self.graph.repoPath(), to: remoteRef.name, mode: 'hard' }, function() {
        context.node(remoteRef.node());
        callback();
      });
    } else {
      callback();
    }
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}

GraphActions.Rebase = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      (!ungit.config.showRebaseAndMergeOnlyOnRefs || self.node.refs().length > 0) &&
      self.graph.currentActionContext().current() &&
      self.graph.currentActionContext().node() != self.node;
  });
}
inherits(GraphActions.Rebase, GraphActions.ActionBase);
GraphActions.Rebase.prototype.text = 'Rebase';
GraphActions.Rebase.prototype.style = 'rebase';
GraphActions.Rebase.prototype.icon = 'octicon octicon-repo-forked flip';
GraphActions.Rebase.prototype.createHoverGraphic = function() {
  var onto = this.graph.currentActionContext();
  if (!onto) return;
  if (onto instanceof RefViewModel) onto = onto.node();
  var path = onto.getPathToCommonAncestor(this.node);
  return new RebaseViewModel(this.node, path);
}
GraphActions.Rebase.prototype.perform = function(callback) {
  this.server.post('/rebase', { path: this.graph.repoPath(), onto: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Merge = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (!self.graph.checkedOutRef() || !self.graph.checkedOutRef().node()) return false;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      !self.graph.currentActionContext().current() &&
      self.graph.checkedOutRef().node() == self.node;
  });
}
inherits(GraphActions.Merge, GraphActions.ActionBase);
GraphActions.Merge.prototype.text = 'Merge';
GraphActions.Merge.prototype.style = 'merge';
GraphActions.Merge.prototype.icon = 'octicon octicon-git-merge';
GraphActions.Merge.prototype.createHoverGraphic = function() {
  var node = this.graph.currentActionContext();
  if (!node) return null;
  if (node instanceof RefViewModel) node = node.node();
  return new MergeViewModel(this.graph, this.node, node);
}
GraphActions.Merge.prototype.perform = function(callback) {
  this.server.post('/merge', { path: this.graph.repoPath(), with: this.graph.currentActionContext().localRefName }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Push = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      self.graph.currentActionContext().canBePushed(self.graph.currentRemote());
  });
}
inherits(GraphActions.Push, GraphActions.ActionBase);
GraphActions.Push.prototype.text = 'Push';
GraphActions.Push.prototype.style = 'push';
GraphActions.Push.prototype.icon = 'octicon octicon-cloud-upload';
GraphActions.Push.prototype.createHoverGraphic = function() {
  var context = this.graph.currentActionContext();
  if (!context) return null;
  var remoteRef = context.getRemoteRef(this.graph.currentRemote());
  if (!remoteRef) return null;
  return new PushViewModel(remoteRef.node(), context.node());
}
GraphActions.Push.prototype.perform = function(callback) {
  var self = this;
  var ref = this.graph.currentActionContext();
  var remoteRef = ref.getRemoteRef(this.graph.currentRemote());

  if (remoteRef) {
    remoteRef.moveTo(ref.node().sha1, callback);
  } else ref.createRemoteRef(function(err) {
    if (!err && self.graph.HEAD().name == ref.name) {
      self.grah.HEADref().node(ref.node());
    }
    callback();
  });
}

GraphActions.Checkout = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    if (self.graph.currentActionContext() instanceof RefViewModel)
      return self.graph.currentActionContext().node() == self.node &&
        !self.graph.currentActionContext().current();
    return ungit.config.allowCheckoutNodes &&
      self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Checkout, GraphActions.ActionBase);
GraphActions.Checkout.prototype.text = 'Checkout';
GraphActions.Checkout.prototype.style = 'checkout';
GraphActions.Checkout.prototype.icon = 'octicon octicon-desktop-download';
GraphActions.Checkout.prototype.perform = function(callback) {
  var self = this;
  var context = this.graph.currentActionContext();
  var refName = context instanceof RefViewModel ? context.refName : context.sha1;
  this.server.post('/checkout', { path: this.graph.repoPath(), name: refName }, function(err) {
    if (err && err.errorCode != 'merge-failed') {
      callback();
      return;
    }

    if (context instanceof RefViewModel && context.isRemoteBranch) {
      self.server.post('/reset', { path: self.graph.repoPath(), to: context.name, mode: 'hard' }, function(err, res) {
        self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
        callback();
        return err && err.errorCode != 'merge-failed' ? undefined : true;
      });
    } else {
      self.graph.HEADref().node(context instanceof RefViewModel ? context.node() : context);
      callback();
    }
    return true;
  });
}

GraphActions.Delete = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() instanceof RefViewModel &&
      self.graph.currentActionContext().node() == self.node &&
      !self.graph.currentActionContext().current();
  });
}
inherits(GraphActions.Delete, GraphActions.ActionBase);
GraphActions.Delete.prototype.text = 'Delete';
GraphActions.Delete.prototype.style = 'delete';
GraphActions.Delete.prototype.icon = 'glyphicon glyphicon-remove';
GraphActions.Delete.prototype.perform = function(callback) {
  var context = this.graph.currentActionContext();
  var name = context.isRemoteBranch ? "remote " + context.localRefName : context.localRefName;
  var diag = components.create('yesnodialog', { title: 'Are you sure?', details: 'Deleting ' + name + ' branch or tag cannot be undone with ungit.'});
  diag.closed.add(function() {
    if (diag.result()) {
      context.remove(callback);
    } else {
      callback();
    }
  });
  programEvents.dispatch({ event: 'request-show-dialog', dialog: diag });
}

GraphActions.CherryPick = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    var context = self.graph.currentActionContext();
    return context === self.node && self.graph.HEAD() && context.sha1 !== self.graph.HEAD().sha1
  });
}
inherits(GraphActions.CherryPick, GraphActions.ActionBase);
GraphActions.CherryPick.prototype.text = 'Cherry pick';
GraphActions.CherryPick.prototype.style = 'cherry-pick';
GraphActions.CherryPick.prototype.icon = 'octicon octicon-circuit-board';
GraphActions.CherryPick.prototype.perform = function(callback) {
  var self = this;
  this.server.post('/cherrypick', { path: this.graph.repoPath(), name: this.node.sha1 }, function(err) {
    callback();
    if (err && err.errorCode == 'merge-failed') return true;
  });
}

GraphActions.Uncommit = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node &&
      self.graph.HEAD() == self.node;
  });
}
inherits(GraphActions.Uncommit, GraphActions.ActionBase);
GraphActions.Uncommit.prototype.text = 'Uncommit';
GraphActions.Uncommit.prototype.style = 'uncommit';
GraphActions.Uncommit.prototype.icon = 'octicon octicon-zap';
GraphActions.Uncommit.prototype.perform = function(callback) {
  var self = this;
  this.server.postPromise('/reset', { path: this.graph.repoPath(), to: 'HEAD^', mode: 'mixed' })
    .then(function() {
      var targetNode = self.node.belowNode;
      while (targetNode && !targetNode.ancestorOfHEAD()) {
        targetNode = targetNode.belowNode;
      }
      self.graph.HEADref().node(targetNode ? targetNode : null);
      self.graph.checkedOutRef().node(targetNode ? targetNode : null);
    }).finally(callback);
}

GraphActions.Revert = function(graph, node) {
  var self = this;
  GraphActions.ActionBase.call(this, graph);
  this.node = node;
  this.visible = ko.computed(function() {
    if (self.performProgressBar.running()) return true;
    return self.graph.currentActionContext() == self.node;
  });
}
inherits(GraphActions.Revert, GraphActions.ActionBase);
GraphActions.Revert.prototype.text = 'Revert';
GraphActions.Revert.prototype.style = 'revert';
GraphActions.Revert.prototype.icon = 'octicon octicon-history';
GraphActions.Revert.prototype.perform = function(callback) {
  var self = this;
  this.server.postPromise('/revert', { path: this.graph.repoPath(), commit: this.node.sha1 })
    .finally(callback);
}

},{"./git-ref.js":5,"./hover-actions":7,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events","util":undefined}],4:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var Selectable = require('./selectable');
var Animateable = require('./animateable');
var programEvents = require('ungit-program-events');
var GraphActions = require('./git-graph-actions');

var GitNodeViewModel = function(graph, sha1) {
  var self = this;
  Selectable.call(this, graph);
  Animateable.call(this);
  this.graph = graph;
  this.sha1 = sha1;
  this.isInited = false;
  this.title = undefined;
  this.parents = ko.observableArray();
  this.commitTime = undefined; // commit time in string
  this.date = undefined;       // commit time in numeric format for sort
  this.color = ko.observable();
  this.ideologicalBranch = ko.observable();
  this.remoteTags = ko.observableArray();
  this.branchesAndLocalTags = ko.observableArray();

  this.refs = ko.computed(function() {
    var rs = self.branchesAndLocalTags().concat(self.remoteTags());
    rs.sort(function(a, b) {
      if (a.isLocal && !b.isLocal) return -1;
      if (!a.isLocal && b.isLocal) return 1;
      return a.refName < b.refName ? -1 : 1;
    });
    return rs;
  });
  this.ancestorOfHEAD = ko.observable(false);
  this.nodeIsMousehover = ko.observable(false);
  this.commitContainerVisible = ko.computed(function() {
    return self.ancestorOfHEAD() || self.nodeIsMousehover() || self.selected();
  });
  this.highlighted = ko.computed(function() {
    return self.nodeIsMousehover() || self.selected();
  });
  this.selected.subscribe(function() {
    programEvents.dispatch({ event: 'graph-render' });
  });
  this.commitComponent = components.create('commit', {
    sha1: this.sha1,
    repoPath: this.graph.repoPath,
    server: this.graph.server,
    selected: this.selected,
    highlighted: this.highlighted,
    nodeIsMousehover: this.nodeIsMousehover
  });
  // These are split up like this because branches and local tags can be found in the git log,
  // whereas remote tags needs to be fetched with another command (which is much slower)
  this.branches = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isBranch; });
  });
  this.tags = ko.computed(function() {
    return self.refs().filter(function(r) { return r.isTag; });
  });
  this.showNewRefAction = ko.computed(function() {
    return !graph.currentActionContext();
  });
  this.newBranchName = ko.observable();
  this.newBranchNameHasFocus = ko.observable(true);
  this.newBranchNameHasFocus.subscribe(function(newValue) {
    if (!newValue) {
      // Small timeout because in ff the form is hidden before the submit click event is registered otherwise
      setTimeout(function() {
        self.branchingFormVisible(false);
      }, 200);
    }
  });
  this.branchingFormVisible = ko.observable(false);
  this.canCreateRef = ko.computed(function() {
    return self.newBranchName() && self.newBranchName().trim() && self.newBranchName().indexOf(' ') == -1;
  });
  this.branchOrder = ko.observable();
  this.aboveNode = undefined;
  this.belowNode = undefined;

  this.r = ko.observable();
  this.cx = ko.observable();
  this.cy = ko.observable();

  this.dropareaGraphActions = [
    new GraphActions.Move(this.graph, this),
    new GraphActions.Rebase(this.graph, this),
    new GraphActions.Merge(this.graph, this),
    new GraphActions.Push(this.graph, this),
    new GraphActions.Reset(this.graph, this),
    new GraphActions.Checkout(this.graph, this),
    new GraphActions.Delete(this.graph, this),
    new GraphActions.CherryPick(this.graph, this),
    new GraphActions.Uncommit(this.graph, this),
    new GraphActions.Revert(this.graph, this)
  ];
}
module.exports = GitNodeViewModel;

GitNodeViewModel.prototype.getGraphAttr = function() {
  return [this.cx(), this.cy()];
}
GitNodeViewModel.prototype.setGraphAttr = function(val) {
  this.element().setAttribute('x', val[0] - 30);
  this.element().setAttribute('y', val[1] - 30);
}
GitNodeViewModel.prototype.render = function() {
  if (!this.isInited) return;
  if (this.ancestorOfHEAD()) {
    this.r(30);
    this.cx(610);

    if (!this.aboveNode) {
      this.cy(120);
    } else if (this.aboveNode.ancestorOfHEAD()) {
      this.cy(this.aboveNode.cy() + 120);
    } else {
      this.cy(this.aboveNode.cy() + 60);
    }
  } else {
    this.r(15);
    this.cx(610 + (90 * this.branchOrder()));
    this.cy(this.aboveNode ? this.aboveNode.cy() + 60 : 120);
  }

  if (this.aboveNode && this.aboveNode.selected()) {
    this.cy(this.aboveNode.cy() + this.aboveNode.commitComponent.element().offsetHeight + 30);
  }

  this.commitComponent.selectedDiffLeftPosition(-(this.cx() - 600));
  this.color(this.ideologicalBranch() ? this.ideologicalBranch().color : '#666');
  this.animate();
}
GitNodeViewModel.prototype.setData = function(logEntry) {
  var self = this;
  this.title = logEntry.message.split('\n')[0];
  this.parents(logEntry.parents || []);
  this.commitTime = logEntry.commitDate;
  this.date = Date.parse(this.commitTime);
  this.commitComponent.setData(logEntry);

  if (logEntry.refs) {
    logEntry.refs.forEach(function(ref) {
      self.graph.getRef(ref).node(self);
    });
  }
  this.isInited = true;
}
GitNodeViewModel.prototype.showBranchingForm = function() {
  this.branchingFormVisible(true);
  this.newBranchNameHasFocus(true);
}
GitNodeViewModel.prototype.createBranch = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  var command = ungit.config.autoCheckoutOnBranchCreate ? "/checkout" : "/branches";

  this.graph.server.postPromise(command, { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(function() {
      self.graph.getRef('refs/heads/' + self.newBranchName()).node(self);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
      programEvents.dispatch({ event: 'branch-updated' });
    });
}
GitNodeViewModel.prototype.createTag = function() {
  if (!this.canCreateRef()) return;
  var self = this;
  this.graph.server.postPromise('/tags', { path: this.graph.repoPath(), name: this.newBranchName(), sha1: this.sha1 })
    .then(function() {
      var newRef = self.graph.getRef('tag: refs/tags/' + self.newBranchName());
      newRef.node(self);
    }).finally(function() {
      self.branchingFormVisible(false);
      self.newBranchName('');
    });
}
GitNodeViewModel.prototype.toggleSelected = function() {
  var self = this;
  var beforeThisCR = this.commitComponent.element().getBoundingClientRect();
  var beforeBelowCR = null;
  if (this.belowNode) {
    beforeBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
  }

  var prevSelected  = this.graph.currentActionContext();
  if (!(prevSelected instanceof GitNodeViewModel)) prevSelected = null;
  var prevSelectedCR = prevSelected ? prevSelected.commitComponent.element().getBoundingClientRect() : null;
  this.selected(!this.selected());

  // If we are deselecting
  if (!this.selected()) {
    if (beforeThisCR.top < 0 && beforeBelowCR) {
      var afterBelowCR = this.belowNode.commitComponent.element().getBoundingClientRect();
      // If the next node is showing, try to keep it in the screen (no jumping)
      if (beforeBelowCR.top < window.innerHeight) {
        window.scrollBy(0, afterBelowCR.top - beforeBelowCR.top);
      // Otherwise just try to bring them to the middle of the screen
      } else {
        window.scrollBy(0, afterBelowCR.top - window.innerHeight / 2);
      }
    }
  // If we are selecting
  } else {
    var afterThisCR = this.commitComponent.element().getBoundingClientRect();
    if ((prevSelectedCR && (prevSelectedCR.top < 0 || prevSelectedCR.top > window.innerHeight)) &&
      afterThisCR.top != beforeThisCR.top) {
      window.scrollBy(0, -(beforeThisCR.top - afterThisCR.top));
      console.log('Fix')
    }
  }
  return false;
}
GitNodeViewModel.prototype.removeRef = function(ref) {
  if (ref.isRemoteTag) {
    this.remoteTags.remove(ref);
  } else {
    this.branchesAndLocalTags.remove(ref);
  }
}
GitNodeViewModel.prototype.pushRef = function(ref) {
  if (ref.isRemoteTag && this.remoteTags.indexOf(ref) < 0) {
    this.remoteTags.push(ref);
  } else if(this.branchesAndLocalTags.indexOf(ref) < 0) {
    this.branchesAndLocalTags.push(ref);
  }
}
GitNodeViewModel.prototype.getPathToCommonAncestor = function(node) {
  var path = [];
  var thisNode = this;
  while (thisNode && !node.isAncestor(thisNode)) {
    path.push(thisNode);
    thisNode = this.graph.nodesById[thisNode.parents()[0]];
  }
  if (thisNode) path.push(thisNode);
  return path;
}
GitNodeViewModel.prototype.isAncestor = function(node) {
  if (node == this) return true;
  for (var v in this.parents()) {
    var n = this.graph.nodesById[this.parents()[v]];
    if (n && n.isAncestor(node)) return true;
  }
  return false;
}
GitNodeViewModel.prototype.getRightToLeftStrike = function() {
  return 'M ' + (this.cx() - 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() + 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.getLeftToRightStrike = function() {
  return 'M ' + (this.cx() + 30) + ' ' + (this.cy() - 30) + ' L ' + (this.cx() - 30) + ' ' + (this.cy() + 30);
}
GitNodeViewModel.prototype.nodeMouseover = function() {
  this.nodeIsMousehover(true);
}
GitNodeViewModel.prototype.nodeMouseout = function() {
  this.nodeIsMousehover(false);
}

},{"./animateable":1,"./git-graph-actions":3,"./selectable":8,"knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],5:[function(require,module,exports){
var ko = require('knockout');
var md5 = require('blueimp-md5');
var Selectable = require('./selectable');
var programEvents = require('ungit-program-events');
var components = require('ungit-components');

var RefViewModel = function(fullRefName, graph) {
  var self = this;
  Selectable.call(this, graph);
  this.graph = graph;
  this.name = fullRefName;
  this.node = ko.observable();
  this.localRefName = this.name; // origin/master or master
  this.refName = this.name; // master
  this.isRemoteTag = this.name.indexOf('remote-tag: ') == 0;
  this.isLocalTag = this.name.indexOf('tag: ') == 0;
  this.isTag = this.isLocalTag || this.isRemoteTag;
  var isRemoteBranchOrHEAD = this.name.indexOf('refs/remotes/') == 0;
  this.isLocalHEAD = this.name == 'HEAD';
  this.isRemoteHEAD = this.name.indexOf('/HEAD') != -1;
  this.isLocalBranch = this.name.indexOf('refs/heads/') == 0;
  this.isRemoteBranch = isRemoteBranchOrHEAD && !this.isRemoteHEAD;
  this.isStash = this.name.indexOf('refs/stash') == 0;
  this.isHEAD = this.isLocalHEAD || this.isRemoteHEAD;
  this.isBranch = this.isLocalBranch || this.isRemoteBranch;
  this.isRemote = isRemoteBranchOrHEAD || this.isRemoteTag;
  this.isLocal = this.isLocalBranch || this.isLocalTag;
  if (this.isLocalBranch) {
    this.localRefName = this.name.slice('refs/heads/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteBranch) {
    this.localRefName = this.name.slice('refs/remotes/'.length);
  }
  if (this.isLocalTag) {
    this.localRefName = this.name.slice('tag: refs/tags/'.length);
    this.refName = this.localRefName;
  }
  if (this.isRemoteTag) {
    this.localRefName = this.name.slice('remote-tag: '.length);
  }
  if (this.isRemote) {
    // get rid of the origin/ part of origin/branchname
    var s = this.localRefName.split('/');
    this.remote = s[0];
    this.refName = s.slice(1).join('/');
  }
  this.show = true;
  this.server = this.graph.server;
  this.isDragging = ko.observable(false);
  this.current = ko.computed(function() {
    return self.isLocalBranch && self.graph.checkedOutBranch() == self.refName;
  });
  this.color = this._colorFromHashOfString(this.name);

  this.node.subscribe(function(oldNode) {
    if (oldNode) oldNode.removeRef(self);
  }, null, "beforeChange");
  this.node.subscribe(function(newNode) {
    if (newNode) newNode.pushRef(self);
  });
};
module.exports = RefViewModel;

RefViewModel.prototype._colorFromHashOfString = function(string) {
  return '#' + md5(string).toString().slice(0, 6);
}
RefViewModel.prototype.dragStart = function() {
  this.graph.currentActionContext(this);
  this.isDragging(true);
  if (document.activeElement) document.activeElement.blur();
}
RefViewModel.prototype.dragEnd = function() {
  this.graph.currentActionContext(null);
  this.isDragging(false);
}
RefViewModel.prototype.moveTo = function(target, callback) {
  var self = this;

  var callbackWithRefSet = function(err, res) {
    if (err) {
      callback(err, res);
    } else {
      var targetNode = self.graph.getNode(target);
      if (self.graph.checkedOutBranch() == self.refName) {
        self.graph.HEADref().node(targetNode);
      }
      self.node(targetNode);
      callback();
    }
  }

  if (this.isLocal) {
    if (this.current()) {
      this.server.post('/reset', { path: this.graph.repoPath(), to: target, mode: 'hard' }, callbackWithRefSet);
    } else if (this.isTag) {
      this.server.post('/tags', { path: this.graph.repoPath(), name: this.refName, sha1: target, force: true }, callbackWithRefSet);
    } else {
      this.server.post('/branches', { path: this.graph.repoPath(), name: this.refName, sha1: target, force: true }, callbackWithRefSet);
    }
  } else {
    var pushReq = { path: this.graph.repoPath(), remote: this.remote, refSpec: target, remoteBranch: this.refName };
    this.server.post('/push', pushReq, function(err, res) {
        if (err) {
          if (err.errorCode == 'non-fast-forward') {
            var forcePushDialog = components.create('yesnodialog', { title: 'Force push?', details: 'The remote branch can\'t be fast-forwarded.' });
            forcePushDialog.closed.add(function() {
              if (!forcePushDialog.result()) return callback();
              pushReq.force = true;
              self.server.post('/push', pushReq, callbackWithRefSet);
            });
            programEvents.dispatch({ event: 'request-show-dialog', dialog: forcePushDialog });
            return true;
          }
        }
        callbackWithRefSet(err, res);
      });
  }
}

RefViewModel.prototype.remove = function(callback) {
  var self = this;
  var url = this.isTag ? '/tags' : '/branches';
  if (this.isRemote) url = '/remote' + url;
  this.server.del(url, { path: this.graph.repoPath(), remote: this.isRemote ? this.remote : null, name: this.refName }, function(err) {
    if (!err) {
      self.node().removeRef(self);
      self.graph.refsByRefName[self.name] = undefined;
    }

    callback();
    self.graph.loadNodesFromApi();
    if (url == '/remote/tags') {
      programEvents.dispatch({ event: 'request-fetch-tags' });
    } else {
      programEvents.dispatch({ event: 'branch-updated' });
    }
  });
}

RefViewModel.prototype.getRemoteRef = function(remote) {
  return this.graph.getRef(this.getRemoteRefFullName(remote), false);
}

RefViewModel.prototype.getRemoteRefFullName = function(remote) {
  if (this.isLocalBranch) return 'refs/remotes/' + remote + '/' + this.refName;
  if (this.isLocalTag) return 'remote-tag: ' + remote + '/' + this.refName;
  return null;
}

RefViewModel.prototype.canBePushed = function(remote) {
  if (!this.isLocal) return false;
  var remoteRef = this.getRemoteRef(remote);
  if (!remoteRef) return true;
  return this.node() != remoteRef.node();
}

RefViewModel.prototype.createRemoteRef = function(callback) {
  var self = this;
  this.server.post('/push', { path: this.graph.repoPath(), remote: this.graph.currentRemote(),
      refSpec: this.refName, remoteBranch: this.refName }, function(err) {
        if (!err) {
          var newRef = self.graph.getRef("refs/remotes/" + self.graph.currentRemote() + "/" + self.refName);
          newRef.node(self.node());
        }
        callback(err);
      });
}

},{"./selectable":8,"blueimp-md5":"blueimp-md5","knockout":"knockout","ungit-components":"ungit-components","ungit-program-events":"ungit-program-events"}],6:[function(require,module,exports){
var ko = require('knockout');
var components = require('ungit-components');
var GitNodeViewModel = require('./git-node');
var GitRefViewModel = require('./git-ref');
var _ = require('lodash');
var moment = require('moment');
var EdgeViewModel = require('./edge');

components.register('graph', function(args) {
  return new GraphViewModel(args.server, args.repoPath);
});

function GraphViewModel(server, repoPath) {
  var self = this;
  this.repoPath = repoPath;
  this.maxNNodes = 25;
  this.server = server;
  this.currentRemote = ko.observable();
  this.nodesLoader = components.create('progressBar', {
    predictionMemoryKey: 'gitgraph-' + self.repoPath(),
    fallbackPredictedTimeMs: 1000,
    temporary: true
  });
  this.nodes = ko.observableArray();
  this.edges = ko.observableArray();
  this.refs = ko.observableArray();
  this.nodesById = {};
  this.refsByRefName = {};
  this.checkedOutBranch = ko.observable();
  this.checkedOutRef = ko.computed(function() {
    return self.checkedOutBranch() ? self.getRef('refs/heads/' + self.checkedOutBranch()) : null;
  });
  this.HEADref = ko.observable();
  this.HEAD = ko.computed(function() {
    return self.HEADref() ? self.HEADref().node() : undefined;
  });
  this.commitNodeColor = ko.computed(function() {
    return self.HEAD() ? self.HEAD().color() : '#4A4A4A';
  });
  this.commitNodeEdge = ko.computed(function() {
    if (!self.HEAD() || !self.HEAD().cx() || !self.HEAD().cy()) return;
    return "M 610 68 L " + self.HEAD().cx() + " " + self.HEAD().cy();
  });
  this.showCommitNode = ko.observable(false);
  this.currentActionContext = ko.observable();
  this.edgesById = {};
  this.scrolledToEnd = _.debounce(function() {
    self.maxNNodes = self.maxNNodes + 25;
    self.loadNodesFromApi();
  }, 500, true);
  this.dimCommit = ko.observable(false);
  this.commitOpacity = ko.computed(function() { return self.dimCommit() ? 0.1 : 1; });
  this.heighstBranchOrder = 0;
  this.hoverGraphActionGraphic = ko.observable();
  this.hoverGraphActionGraphic.subscribe(function(value) {
    if (value && value.destroy)
      value.destroy();
  }, null, 'beforeChange');

  this.hoverGraphAction = ko.observable();
  this.hoverGraphAction.subscribe(function(value) {
    if (value && value.createHoverGraphic) {
      self.hoverGraphActionGraphic(value.createHoverGraphic());
    } else {
      self.hoverGraphActionGraphic(null);
    }
  });

  this.loadNodesFromApiThrottled = _.throttle(this.loadNodesFromApi.bind(this), 500);
  this.updateBranchesThrottled = _.throttle(this.updateBranches.bind(this), 500);
  this.loadNodesFromApiThrottled();
  this.updateBranchesThrottled();
  this.graphWidth = ko.observable();
  this.graphHeight = ko.observable();
}

GraphViewModel.prototype.updateNode = function(parentElement) {
  ko.renderTemplate('graph', this, {}, parentElement);
}

GraphViewModel.prototype.getNode = function(sha1, logEntry) {
  var nodeViewModel = this.nodesById[sha1];
  if (!nodeViewModel) nodeViewModel = this.nodesById[sha1] = new GitNodeViewModel(this, sha1);
  if (logEntry) nodeViewModel.setData(logEntry);
  return nodeViewModel;
}
GraphViewModel.prototype.getRef = function(ref, constructIfUnavailable) {
  if (constructIfUnavailable === undefined) constructIfUnavailable = true;
  var refViewModel = this.refsByRefName[ref];
  if (!refViewModel && constructIfUnavailable) {
    refViewModel = this.refsByRefName[ref] = new GitRefViewModel(ref, this);
    this.refs.push(refViewModel);
    if (refViewModel.name === 'HEAD') {
      this.HEADref(refViewModel);
    }
  }
  return refViewModel;
}

GraphViewModel.prototype.loadNodesFromApi = function(callback) {
  var self = this;

  this.nodesLoader.start();
  this.server.getPromise('/log', { path: this.repoPath(), limit: this.maxNNodes })
    .then(function(nodes) {
      nodes = self.computeNode(nodes.map(function(logEntry) {
          return self.getNode(logEntry.sha1, logEntry);
        }));

      var edges = [];
      nodes.forEach(function(node) {
        node.parents().forEach(function(parentSha1) {
          edges.push(self.getEdge(node.sha1, parentSha1));
        });
        node.render();
      });

      self.edges(edges);
      self.nodes(nodes);

      if (nodes.length > 0) {
        self.graphHeight(nodes[nodes.length - 1].cy() + 80);
      }
      self.graphWidth(1000 + (self.heighstBranchOrder * 90));
    }).finally(function() {
      self.nodesLoader.stop();
      if (callback) callback();
    });
}

GraphViewModel.prototype.traverseNodeLeftParents = function(node, callback) {
  callback(node);
  var parent = this.nodesById[node.parents()[0]];
  if (parent) {
    this.traverseNodeLeftParents(parent, callback);
  }
}

GraphViewModel.prototype.computeNode = function(nodes) {
  var self = this;

  if (!nodes) {
    nodes = this.nodes();
  }

  this.markNodesIdeologicalBranches(this.refs(), nodes, this.nodesById);

  var updateTimeStamp = moment().valueOf();
  if (this.HEAD()) {
    this.traverseNodeLeftParents(this.HEAD(), function(node) {
      node.ancestorOfHEADTimeStamp = updateTimeStamp;
    });
  }

  // Filter out nodes which doesn't have a branch (staging and orphaned nodes)
  nodes = nodes.filter(function(node) { return (node.ideologicalBranch() && !node.ideologicalBranch().isStash) || node.ancestorOfHEADTimeStamp == updateTimeStamp; })

  var branchSlots = [];

  // Then iterate from the bottom to fix the orders of the branches
  for (var i = nodes.length - 1; i >= 0; i--) {
    var node = nodes[i];
    if (node.ancestorOfHEADTimeStamp == updateTimeStamp) continue;
    var ideologicalBranch = node.ideologicalBranch();

    // First occurence of the branch, find an empty slot for the branch
    if (ideologicalBranch.lastSlottedTimeStamp != updateTimeStamp) {
      ideologicalBranch.lastSlottedTimeStamp = updateTimeStamp;
      var slot = branchSlots.indexOf(undefined);
      if (slot === -1) {
        branchSlots.push(ideologicalBranch);
        slot = branchSlots.length - 1;
      }
      ideologicalBranch.branchOrder = slot;
      branchSlots[slot] = slot;
    }

    node.branchOrder(ideologicalBranch.branchOrder);
    self.heighstBranchOrder = Math.max(self.heighstBranchOrder, node.branchOrder());
  }

  var prevNode;
  nodes.forEach(function(node) {
    node.branchOrder(branchSlots.length - node.branchOrder());
    node.ancestorOfHEAD(node.ancestorOfHEADTimeStamp == updateTimeStamp);
    node.aboveNode = prevNode;
    if (prevNode) prevNode.belowNode = node;
    prevNode = node;
  });

  return nodes;
}

GraphViewModel.prototype.getEdge = function(nodeAsha1, nodeBsha1) {
  var id = nodeAsha1 + '-' + nodeBsha1;
  var edge = this.edgesById[id];
  if (!edge) {
    edge = this.edgesById[id] = new EdgeViewModel(this, nodeAsha1, nodeBsha1);
  }
  return edge;
}

GraphViewModel._markIdeologicalStamp = 0;
GraphViewModel.prototype.markNodesIdeologicalBranches = function(refs, nodes, nodesById) {
  var self = this;
  refs = refs.filter(function(r) { return !!r.node(); });
  refs = refs.sort(function(a, b) {
    if (a.isLocal && !b.isLocal) return -1;
    if (b.isLocal && !a.isLocal) return 1;
    if (a.isBranch && !b.isBranch) return -1;
    if (b.isBranch && !a.isBranch) return 1;
    if (a.isHEAD && !b.isHEAD) return 1;
    if (!a.isHEAD && b.isHEAD) return -1;
    if (a.isStash && !b.isStash) return 1;
    if (b.isStash && !a.isStash) return -1;
    if (a.node() && a.node().date && b.node() && b.node().date)
      return b.node().date - a.node().date;
    return a.refName < b.refName ? -1 : 1;
  });
  var stamp = GraphViewModel._markIdeologicalStamp++;
  refs.forEach(function(ref) {
    self.traverseNodeParents(ref.node(), function(node) {
      if (node.stamp == stamp) return false;
      node.stamp = stamp;
      node.ideologicalBranch(ref);
      return true;
    });
  });
}

GraphViewModel.prototype.traverseNodeParents = function(node, callback) {
  if (!callback(node)) return false;
  for (var i = 0; i < node.parents().length; i++) {
    // if parent, travers parent
    var parent = this.nodesById[node.parents()[i]];
    if (parent) {
      this.traverseNodeParents(parent, callback);
    }
  }
}

GraphViewModel.prototype.handleBubbledClick = function(elem, event) {
  // If the clicked element is bound to the current action context,
  // then let's not deselect it.
  if (ko.dataFor(event.target) === this.currentActionContext()) return;
  if (this.currentActionContext() && this.currentActionContext() instanceof GitNodeViewModel) {
    this.currentActionContext().toggleSelected();
  } else {
    this.currentActionContext(null);
  }
  // If the click was on an input element, then let's allow the default action to proceed.
  // This is especially needed since for some strange reason any submit (ie. enter in a textbox)
  // will trigger a click event on the submit input of the form, which will end up here,
  // and if we don't return true, then the submit event is never fired, breaking stuff.
  if (event.target.nodeName === 'INPUT') return true;
}

GraphViewModel.prototype.onProgramEvent = function(event) {
  if (event.event == 'git-directory-changed') {
    this.loadNodesFromApiThrottled();
    this.updateBranchesThrottled();
  } else if (event.event == 'request-app-content-refresh') {
    this.loadNodesFromApiThrottled();
  } else if (event.event == 'remote-tags-update') {
    this.setRemoteTags(event.tags);
  } else if (event.event == 'current-remote-changed') {
    this.currentRemote(event.newRemote);
  } else if (event.event == 'graph-render') {
    this.nodes().forEach(function(node) {
      node.render();
    });
  }
}
GraphViewModel.prototype.updateBranches = function() {
  var self = this;
  this.server.get('/checkout', { path: this.repoPath() }, function(err, branch) {
    if (err && err.errorCode == 'not-a-repository') return true;
    if (err) return;
    self.checkedOutBranch(branch);
  });
}
GraphViewModel.prototype.setRemoteTags = function(remoteTags) {
  var self = this;
  var nodeIdsToRemoteTags = {};
  remoteTags.forEach(function(ref) {
    if (ref.name.indexOf('^{}') != -1) {
      var tagRef = ref.name.slice(0, ref.name.length - '^{}'.length);
      var name = 'remote-tag: ' + ref.remote + '/' + tagRef.split('/')[2];
      self.getRef(name).node(self.getNode(ref.sha1));
    }
  });
}
GraphViewModel.prototype.checkHeadMove = function(toNode) {
  if (this.HEAD() === toNode) {
    this.HEADref.node(toNode);
  }
}

},{"./edge":2,"./git-node":4,"./git-ref":5,"knockout":"knockout","lodash":"lodash","moment":"moment","ungit-components":"ungit-components"}],7:[function(require,module,exports){
var getEdgeModelWithD = function(d, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return { d: d,
          stroke: stroke ? stroke : '#4A4A4A',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5',
          markerEnd: markerEnd ? markerEnd : '' };
}

var getEdgeModel = function(scx, scy, tcx, tcy, stroke, strokeWidth, strokeDasharray, markerEnd) {
  return getEdgeModelWithD("M " + scx + " " + scy + " L " + tcx + " " + tcy, stroke, strokeWidth, strokeDasharray, markerEnd);
}

var getNodeModel = function(cx, cy, r, fill, stroke, strokeWidth, strokeDasharray) {
  return { cx: cx,
          cy: cy,
          r: r,
          fill: fill,
          stroke: stroke ? stroke : '#41DE3C',
          strokeWidth: strokeWidth ? strokeWidth : '8',
          strokeDasharray: strokeDasharray ? strokeDasharray : '10, 5' };
}

function HoverViewModel() {
  this.bgEdges = [];
  this.nodes = [];
  this.fgEdges = [];
}

function MergeViewModel(graph, headNode, node) {
  var self = this;
  HoverViewModel.call(this);
  this.graph = graph;
  this.bgEdges = [ getEdgeModel(headNode.cx(), (headNode.cy() - 110), headNode.cx(), headNode.cy()),
                getEdgeModel(headNode.cx(), (headNode.cy() - 110), node.cx(), node.cy()) ];
  this.nodes = [ getNodeModel(headNode.cx(), headNode.cy() - 110, Math.max(headNode.r(), node.r()), '#252833', '#41DE3C', '8', '10, 5') ];

  graph.dimCommit(true);
}
exports.MergeViewModel = MergeViewModel;
MergeViewModel.prototype.destroy = function() {
  this.graph.dimCommit(false);
}

function RebaseViewModel(onto, nodesThatWillMove) {
  var self = this;
  HoverViewModel.call(this);
  nodesThatWillMove = nodesThatWillMove.slice(0, -1);

  if (nodesThatWillMove.length == 0) return;

  this.bgEdges.push(getEdgeModel(onto.cx(), onto.cy(), onto.cx(), onto.cy() - 60));
  nodesThatWillMove.forEach(function(node, i) {
    var cy = onto.cy() + (-90 * (i + 1));
    self.nodes.push(getNodeModel(onto.cx(), cy, 28, 'transparent'));
    if (i + 1 < nodesThatWillMove.length) {
      self.bgEdges.push(getEdgeModel(onto.cx(), (cy - 25), onto.cx(), (cy - 65)));
    }
  });
}
exports.RebaseViewModel = RebaseViewModel;

function ResetViewModel(nodes) {
  var self = this;
  HoverViewModel.call(this);

  nodes.forEach(function(node) {
    self.fgEdges.push(getEdgeModelWithD(node.getLeftToRightStrike(), 'rgb(255, 129, 31)', '8', '0, 0'))
    self.fgEdges.push(getEdgeModelWithD(node.getRightToLeftStrike(), 'rgb(255, 129, 31)', '8', '0, 0'));
  });
}
exports.ResetViewModel = ResetViewModel;

function PushViewModel(fromNode, toNode) {
  HoverViewModel.call(this);
  this.fgEdges = [getEdgeModel(fromNode.cx(), fromNode.cy(), toNode.cx(), (toNode.cy() + 40), 'rgb(61, 139, 255)', '15', '10, 5', 'url(#pushArrowEnd)' )];
}
exports.PushViewModel = PushViewModel;

},{}],8:[function(require,module,exports){
var ko = require('knockout');

var Selectable = function(graph) {
  this.selected = ko.computed({
    read: function() {
      return graph.currentActionContext() == this;
    },
    write: function(val) {
      // val is this if we're called from a click ko binding
      if (val === this || val === true) {
        graph.currentActionContext(this);
      } else if (graph.currentActionContext() == this) {
        graph.currentActionContext(null);
      }
    },
    owner: this
  });
};
module.exports = Selectable;

},{"knockout":"knockout"}]},{},[6])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2FuaW1hdGVhYmxlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9lZGdlLmpzIiwiY29tcG9uZW50cy9ncmFwaC9naXQtZ3JhcGgtYWN0aW9ucy5qcyIsImNvbXBvbmVudHMvZ3JhcGgvZ2l0LW5vZGUuanMiLCJjb21wb25lbnRzL2dyYXBoL2dpdC1yZWYuanMiLCJjb21wb25lbnRzL2dyYXBoL2dyYXBoLmpzIiwiY29tcG9uZW50cy9ncmFwaC9ob3Zlci1hY3Rpb25zLmpzIiwiY29tcG9uZW50cy9ncmFwaC9zZWxlY3RhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xucmVxdWlyZSgnbWluYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5lbGVtZW50ID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLnByZXZpb3VzR3JhcGggPSB1bmRlZmluZWQ7XG4gIHRoaXMuZWxlbWVudC5zdWJzY3JpYmUoZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHZhbCkgc2VsZi5hbmltYXRlKHRydWUpO1xuICB9KTtcbiAgdGhpcy5hbmltYXRlID0gZnVuY3Rpb24oZm9yY2VSZWZyZXNoKSB7XG4gICAgdmFyIGN1cnJlbnRHcmFwaCA9IHRoaXMuZ2V0R3JhcGhBdHRyKCk7XG4gICAgLy8gYW5pbWF0ZSBvbmx5IHdoZW4gZG9tIGlzIHZhbGlkIGFuZCAoYXR0cmlidXRlIGNoYW5nZWQgb3IgZm9yY2UgcmVmcmVzaCBkdWUgdG8gZG9tIGNoYW5nZSlcbiAgICBpZiAodGhpcy5lbGVtZW50KCkgJiYgKGZvcmNlUmVmcmVzaCB8fCBKU09OLnN0cmluZ2lmeShjdXJyZW50R3JhcGgpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLnByZXZpb3VzR3JhcGgpKSkge1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICB3aW5kb3cubWluYSh0aGlzLnByZXZpb3VzR3JhcGggfHwgY3VycmVudEdyYXBoLCBjdXJyZW50R3JhcGgsIG5vdywgbm93ICsgNzUwLCB3aW5kb3cubWluYS50aW1lLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHNlbGYuc2V0R3JhcGhBdHRyKHZhbCk7XG4gICAgICB9LCB3aW5kb3cubWluYS5lbGFzdGljKTtcbiAgICAgIHRoaXMucHJldmlvdXNHcmFwaCA9IGN1cnJlbnRHcmFwaDtcbiAgICB9XG4gIH1cbn07XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIEFuaW1hdGVhYmxlID0gcmVxdWlyZSgnLi9hbmltYXRlYWJsZScpO1xuXG52YXIgRWRnZVZpZXdNb2RlbCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlQXNoYTEsIG5vZGVCc2hhMSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEFuaW1hdGVhYmxlLmNhbGwodGhpcyk7XG4gIHRoaXMubm9kZUEgPSBncmFwaC5nZXROb2RlKG5vZGVBc2hhMSk7XG4gIHRoaXMubm9kZUIgPSBncmFwaC5nZXROb2RlKG5vZGVCc2hhMSk7XG4gIHRoaXMuZ2V0R3JhcGhBdHRyID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYubm9kZUIuaXNJbml0ZWQgJiYgc2VsZi5ub2RlQi5jeCgpICYmIHNlbGYubm9kZUIuY3koKSkge1xuICAgICAgcmV0dXJuIFtzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSwgc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksXG4gICAgICAgICAgICAgIHNlbGYubm9kZUIuY3goKSwgc2VsZi5ub2RlQi5jeSgpLCBzZWxmLm5vZGVCLmN4KCksIHNlbGYubm9kZUIuY3koKV07XG4gICAgfSBlbHNlIGlmIChncmFwaC5ncmFwaEhlaWdodCgpKSB7XG4gICAgICByZXR1cm4gW3NlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLCBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgc2VsZi5ub2RlQS5jeCgpLCBncmFwaC5ncmFwaEhlaWdodCgpLCBzZWxmLm5vZGVBLmN4KCksIGdyYXBoLmdyYXBoSGVpZ2h0KCldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3NlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpLCBzZWxmLm5vZGVBLmN4KCksIHNlbGYubm9kZUEuY3koKSxcbiAgICAgICAgICAgICAgc2VsZi5ub2RlQS5jeCgpLCBzZWxmLm5vZGVBLmN5KCksIHNlbGYubm9kZUEuY3goKSwgc2VsZi5ub2RlQS5jeSgpXTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmdldEdyYXBoQXR0ci5zdWJzY3JpYmUodGhpcy5hbmltYXRlLmJpbmQodGhpcykpO1xufVxuRWRnZVZpZXdNb2RlbC5wcm90b3R5cGUuc2V0R3JhcGhBdHRyID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgnZCcsICdNJyArIHZhbC5zbGljZSgwLDQpLmpvaW4oJywnKSArICdMJyArIHZhbC5zbGljZSg0LDgpLmpvaW4oJywnKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVkZ2VWaWV3TW9kZWw7XG4iLCJcbnZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBSZWZWaWV3TW9kZWwgPSByZXF1aXJlKCcuL2dpdC1yZWYuanMnKTtcbnZhciBIb3ZlckFjdGlvbnMgPSByZXF1aXJlKCcuL2hvdmVyLWFjdGlvbnMnKTtcbnZhciBSZWJhc2VWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUmViYXNlVmlld01vZGVsO1xudmFyIE1lcmdlVmlld01vZGVsID0gSG92ZXJBY3Rpb25zLk1lcmdlVmlld01vZGVsO1xudmFyIFJlc2V0Vmlld01vZGVsID0gSG92ZXJBY3Rpb25zLlJlc2V0Vmlld01vZGVsO1xudmFyIFB1c2hWaWV3TW9kZWwgPSBIb3ZlckFjdGlvbnMuUHVzaFZpZXdNb2RlbDtcbnZhciBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcblxudmFyIEdyYXBoQWN0aW9ucyA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBHcmFwaEFjdGlvbnM7XG5cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMuc2VydmVyID0gZ3JhcGguc2VydmVyO1xuICB0aGlzLnBlcmZvcm1Qcm9ncmVzc0JhciA9IGNvbXBvbmVudHMuY3JlYXRlKCdwcm9ncmVzc0JhcicsIHtcbiAgICBwcmVkaWN0aW9uTWVtb3J5S2V5OiAnYWN0aW9uLScgKyB0aGlzLnN0eWxlICsgJy0nICsgZ3JhcGgucmVwb1BhdGgoKSxcbiAgICBmYWxsYmFja1ByZWRpY3RlZFRpbWVNczogMTAwMCxcbiAgICB0ZW1wb3Jhcnk6IHRydWVcbiAgfSk7XG5cbiAgdGhpcy5pc0hpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICFncmFwaC5ob3ZlckdyYXBoQWN0aW9uKCkgfHwgZ3JhcGguaG92ZXJHcmFwaEFjdGlvbigpID09IHNlbGY7XG4gIH0pO1xuICB0aGlzLmNzc0NsYXNzZXMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IHNlbGYuc3R5bGU7XG4gICAgaWYgKCFzZWxmLmlzSGlnaGxpZ2h0ZWQoKSkgYyArPSAnIGRpbW1lZCc7XG4gICAgcmV0dXJuIGM7XG4gIH0pXG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuaWNvbiA9IG51bGw7XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZG9QZXJmb3JtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xuICBzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5zdGFydCgpO1xuICB0aGlzLnBlcmZvcm0oZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIuc3RvcCgpO1xuICB9KTtcbn1cbkdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLnByb3RvdHlwZS5kcmFnRW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnZpc2libGUoKSkgcmV0dXJuO1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUuZHJhZ0xlYXZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy52aXNpYmxlKCkpIHJldHVybjtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UucHJvdG90eXBlLm1vdXNlb3ZlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdyYXBoLmhvdmVyR3JhcGhBY3Rpb24odGhpcyk7XG59XG5HcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5ob3ZlckdyYXBoQWN0aW9uKG51bGwpO1xufVxuXG5HcmFwaEFjdGlvbnMuTW92ZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgIT0gc2VsZi5ub2RlO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5Nb3ZlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuTW92ZS5wcm90b3R5cGUudGV4dCA9ICdNb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5zdHlsZSA9ICdtb3ZlJztcbkdyYXBoQWN0aW9ucy5Nb3ZlLnByb3RvdHlwZS5pY29uID0gJ2dseXBoaWNvbiBnbHlwaGljb24tbW92ZSc7XG5HcmFwaEFjdGlvbnMuTW92ZS5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5tb3ZlVG8odGhpcy5ub2RlLnNoYTEsIGNhbGxiYWNrKTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlc2V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0Lm5vZGUoKSAhPSBzZWxmLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcmVtb3RlUmVmID0gY29udGV4dC5nZXRSZW1vdGVSZWYoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICAgIHJldHVybiByZW1vdGVSZWYgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkgIT0gY29udGV4dC5ub2RlKCkgJiZcbiAgICAgIHJlbW90ZVJlZi5ub2RlKCkuZGF0ZSA8IGNvbnRleHQubm9kZSgpLmRhdGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlc2V0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLnRleHQgPSAnUmVzZXQnO1xuR3JhcGhBY3Rpb25zLlJlc2V0LnByb3RvdHlwZS5zdHlsZSA9ICdyZXNldCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmljb24gPSAnZ2x5cGhpY29uIGdseXBoaWNvbi10cmFzaCc7XG5HcmFwaEFjdGlvbnMuUmVzZXQucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgdmFyIG5vZGVzID0gY29udGV4dC5ub2RlKCkuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IocmVtb3RlUmVmLm5vZGUoKSkuc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gbmV3IFJlc2V0Vmlld01vZGVsKG5vZGVzKTtcbn1cbkdyYXBoQWN0aW9ucy5SZXNldC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZW1vdGVSZWYgPSBjb250ZXh0LmdldFJlbW90ZVJlZihzZWxmLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSk7XG4gIHZhciBkaWFnID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0FyZSB5b3Ugc3VyZT8nLCBkZXRhaWxzOiAnUmVzZXR0aW5nIHRvIHJlZjogJyArIHJlbW90ZVJlZi5uYW1lICsgJyBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pO1xuICBkaWFnLmNsb3NlZC5hZGQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgIHNlbGYuc2VydmVyLnBvc3QoJy9yZXNldCcsIHsgcGF0aDogc2VsZi5ncmFwaC5yZXBvUGF0aCgpLCB0bzogcmVtb3RlUmVmLm5hbWUsIG1vZGU6ICdoYXJkJyB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29udGV4dC5ub2RlKHJlbW90ZVJlZi5ub2RlKCkpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9KTtcbiAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1zaG93LWRpYWxvZycsIGRpYWxvZzogZGlhZyB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlJlYmFzZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgICghdW5naXQuY29uZmlnLnNob3dSZWJhc2VBbmRNZXJnZU9ubHlPblJlZnMgfHwgc2VsZi5ub2RlLnJlZnMoKS5sZW5ndGggPiAwKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLm5vZGUoKSAhPSBzZWxmLm5vZGU7XG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLlJlYmFzZSwgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UpO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUudGV4dCA9ICdSZWJhc2UnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuc3R5bGUgPSAncmViYXNlJztcbkdyYXBoQWN0aW9ucy5SZWJhc2UucHJvdG90eXBlLmljb24gPSAnb2N0aWNvbiBvY3RpY29uLXJlcG8tZm9ya2VkIGZsaXAnO1xuR3JhcGhBY3Rpb25zLlJlYmFzZS5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvbnRvID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW9udG8pIHJldHVybjtcbiAgaWYgKG9udG8gaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwpIG9udG8gPSBvbnRvLm5vZGUoKTtcbiAgdmFyIHBhdGggPSBvbnRvLmdldFBhdGhUb0NvbW1vbkFuY2VzdG9yKHRoaXMubm9kZSk7XG4gIHJldHVybiBuZXcgUmViYXNlVmlld01vZGVsKHRoaXMubm9kZSwgcGF0aCk7XG59XG5HcmFwaEFjdGlvbnMuUmViYXNlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3JlYmFzZScsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBvbnRvOiB0aGlzLm5vZGUuc2hhMSB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSA9PSAnbWVyZ2UtZmFpbGVkJykgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuTWVyZ2UgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNlbGYuZ3JhcGguY2hlY2tlZE91dFJlZigpIHx8ICFzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKS5ub2RlKCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpIGluc3RhbmNlb2YgUmVmVmlld01vZGVsICYmXG4gICAgICAhc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKSAmJlxuICAgICAgc2VsZi5ncmFwaC5jaGVja2VkT3V0UmVmKCkubm9kZSgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuTWVyZ2UsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5NZXJnZS5wcm90b3R5cGUudGV4dCA9ICdNZXJnZSc7XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnN0eWxlID0gJ21lcmdlJztcbkdyYXBoQWN0aW9ucy5NZXJnZS5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tZ2l0LW1lcmdlJztcbkdyYXBoQWN0aW9ucy5NZXJnZS5wcm90b3R5cGUuY3JlYXRlSG92ZXJHcmFwaGljID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICBpZiAoIW5vZGUpIHJldHVybiBudWxsO1xuICBpZiAobm9kZSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCkgbm9kZSA9IG5vZGUubm9kZSgpO1xuICByZXR1cm4gbmV3IE1lcmdlVmlld01vZGVsKHRoaXMuZ3JhcGgsIHRoaXMubm9kZSwgbm9kZSk7XG59XG5HcmFwaEFjdGlvbnMuTWVyZ2UucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLnNlcnZlci5wb3N0KCcvbWVyZ2UnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgd2l0aDogdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmxvY2FsUmVmTmFtZSB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSA9PSAnbWVyZ2UtZmFpbGVkJykgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuUHVzaCA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gc2VsZi5ub2RlICYmXG4gICAgICBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkuY2FuQmVQdXNoZWQoc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkpO1xuICB9KTtcbn1cbmluaGVyaXRzKEdyYXBoQWN0aW9ucy5QdXNoLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUHVzaC5wcm90b3R5cGUudGV4dCA9ICdQdXNoJztcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS5zdHlsZSA9ICdwdXNoJztcbkdyYXBoQWN0aW9ucy5QdXNoLnByb3RvdHlwZS5pY29uID0gJ29jdGljb24gb2N0aWNvbi1jbG91ZC11cGxvYWQnO1xuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLmNyZWF0ZUhvdmVyR3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGV4dCA9IHRoaXMuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgdmFyIHJlbW90ZVJlZiA9IGNvbnRleHQuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcbiAgaWYgKCFyZW1vdGVSZWYpIHJldHVybiBudWxsO1xuICByZXR1cm4gbmV3IFB1c2hWaWV3TW9kZWwocmVtb3RlUmVmLm5vZGUoKSwgY29udGV4dC5ub2RlKCkpO1xufVxuR3JhcGhBY3Rpb25zLlB1c2gucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZWYgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciByZW1vdGVSZWYgPSByZWYuZ2V0UmVtb3RlUmVmKHRoaXMuZ3JhcGguY3VycmVudFJlbW90ZSgpKTtcblxuICBpZiAocmVtb3RlUmVmKSB7XG4gICAgcmVtb3RlUmVmLm1vdmVUbyhyZWYubm9kZSgpLnNoYTEsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIHJlZi5jcmVhdGVSZW1vdGVSZWYoZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKCFlcnIgJiYgc2VsZi5ncmFwaC5IRUFEKCkubmFtZSA9PSByZWYubmFtZSkge1xuICAgICAgc2VsZi5ncmFoLkhFQURyZWYoKS5ub2RlKHJlZi5ub2RlKCkpO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLkNoZWNrb3V0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbClcbiAgICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkubm9kZSgpID09IHNlbGYubm9kZSAmJlxuICAgICAgICAhc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKTtcbiAgICByZXR1cm4gdW5naXQuY29uZmlnLmFsbG93Q2hlY2tvdXROb2RlcyAmJlxuICAgICAgc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuQ2hlY2tvdXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUudGV4dCA9ICdDaGVja291dCc7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnN0eWxlID0gJ2NoZWNrb3V0JztcbkdyYXBoQWN0aW9ucy5DaGVja291dC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tZGVza3RvcC1kb3dubG9hZCc7XG5HcmFwaEFjdGlvbnMuQ2hlY2tvdXQucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICB2YXIgcmVmTmFtZSA9IGNvbnRleHQgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgPyBjb250ZXh0LnJlZk5hbWUgOiBjb250ZXh0LnNoYTE7XG4gIHRoaXMuc2VydmVyLnBvc3QoJy9jaGVja291dCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiByZWZOYW1lIH0sIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCAmJiBjb250ZXh0LmlzUmVtb3RlQnJhbmNoKSB7XG4gICAgICBzZWxmLnNlcnZlci5wb3N0KCcvcmVzZXQnLCB7IHBhdGg6IHNlbGYuZ3JhcGgucmVwb1BhdGgoKSwgdG86IGNvbnRleHQubmFtZSwgbW9kZTogJ2hhcmQnIH0sIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIHNlbGYuZ3JhcGguSEVBRHJlZigpLm5vZGUoY29udGV4dCBpbnN0YW5jZW9mIFJlZlZpZXdNb2RlbCA/IGNvbnRleHQubm9kZSgpIDogY29udGV4dCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiBlcnIgJiYgZXJyLmVycm9yQ29kZSAhPSAnbWVyZ2UtZmFpbGVkJyA/IHVuZGVmaW5lZCA6IHRydWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ncmFwaC5IRUFEcmVmKCkubm9kZShjb250ZXh0IGluc3RhbmNlb2YgUmVmVmlld01vZGVsID8gY29udGV4dC5ub2RlKCkgOiBjb250ZXh0KTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLkRlbGV0ZSA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzZWxmLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkgaW5zdGFuY2VvZiBSZWZWaWV3TW9kZWwgJiZcbiAgICAgIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKS5ub2RlKCkgPT0gc2VsZi5ub2RlICYmXG4gICAgICAhc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpLmN1cnJlbnQoKTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuRGVsZXRlLCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuRGVsZXRlLnByb3RvdHlwZS50ZXh0ID0gJ0RlbGV0ZSc7XG5HcmFwaEFjdGlvbnMuRGVsZXRlLnByb3RvdHlwZS5zdHlsZSA9ICdkZWxldGUnO1xuR3JhcGhBY3Rpb25zLkRlbGV0ZS5wcm90b3R5cGUuaWNvbiA9ICdnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZSc7XG5HcmFwaEFjdGlvbnMuRGVsZXRlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIHZhciBuYW1lID0gY29udGV4dC5pc1JlbW90ZUJyYW5jaCA/IFwicmVtb3RlIFwiICsgY29udGV4dC5sb2NhbFJlZk5hbWUgOiBjb250ZXh0LmxvY2FsUmVmTmFtZTtcbiAgdmFyIGRpYWcgPSBjb21wb25lbnRzLmNyZWF0ZSgneWVzbm9kaWFsb2cnLCB7IHRpdGxlOiAnQXJlIHlvdSBzdXJlPycsIGRldGFpbHM6ICdEZWxldGluZyAnICsgbmFtZSArICcgYnJhbmNoIG9yIHRhZyBjYW5ub3QgYmUgdW5kb25lIHdpdGggdW5naXQuJ30pO1xuICBkaWFnLmNsb3NlZC5hZGQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRpYWcucmVzdWx0KCkpIHtcbiAgICAgIGNvbnRleHQucmVtb3ZlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pO1xuICBwcm9ncmFtRXZlbnRzLmRpc3BhdGNoKHsgZXZlbnQ6ICdyZXF1ZXN0LXNob3ctZGlhbG9nJywgZGlhbG9nOiBkaWFnIH0pO1xufVxuXG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljayA9IGZ1bmN0aW9uKGdyYXBoLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgR3JhcGhBY3Rpb25zLkFjdGlvbkJhc2UuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMudmlzaWJsZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnBlcmZvcm1Qcm9ncmVzc0Jhci5ydW5uaW5nKCkpIHJldHVybiB0cnVlO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpO1xuICAgIHJldHVybiBjb250ZXh0ID09PSBzZWxmLm5vZGUgJiYgc2VsZi5ncmFwaC5IRUFEKCkgJiYgY29udGV4dC5zaGExICE9PSBzZWxmLmdyYXBoLkhFQUQoKS5zaGExXG4gIH0pO1xufVxuaW5oZXJpdHMoR3JhcGhBY3Rpb25zLkNoZXJyeVBpY2ssIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS50ZXh0ID0gJ0NoZXJyeSBwaWNrJztcbkdyYXBoQWN0aW9ucy5DaGVycnlQaWNrLnByb3RvdHlwZS5zdHlsZSA9ICdjaGVycnktcGljayc7XG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljay5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24tY2lyY3VpdC1ib2FyZCc7XG5HcmFwaEFjdGlvbnMuQ2hlcnJ5UGljay5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL2NoZXJyeXBpY2snLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgbmFtZTogdGhpcy5ub2RlLnNoYTEgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ21lcmdlLWZhaWxlZCcpIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuR3JhcGhBY3Rpb25zLlVuY29tbWl0ID0gZnVuY3Rpb24oZ3JhcGgsIG5vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZS5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy52aXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYucGVyZm9ybVByb2dyZXNzQmFyLnJ1bm5pbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHNlbGYuZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSBzZWxmLm5vZGUgJiZcbiAgICAgIHNlbGYuZ3JhcGguSEVBRCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuVW5jb21taXQsIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlKTtcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUudGV4dCA9ICdVbmNvbW1pdCc7XG5HcmFwaEFjdGlvbnMuVW5jb21taXQucHJvdG90eXBlLnN0eWxlID0gJ3VuY29tbWl0JztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24temFwJztcbkdyYXBoQWN0aW9ucy5VbmNvbW1pdC5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdFByb21pc2UoJy9yZXNldCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCB0bzogJ0hFQUReJywgbW9kZTogJ21peGVkJyB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBzZWxmLm5vZGUuYmVsb3dOb2RlO1xuICAgICAgd2hpbGUgKHRhcmdldE5vZGUgJiYgIXRhcmdldE5vZGUuYW5jZXN0b3JPZkhFQUQoKSkge1xuICAgICAgICB0YXJnZXROb2RlID0gdGFyZ2V0Tm9kZS5iZWxvd05vZGU7XG4gICAgICB9XG4gICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKHRhcmdldE5vZGUgPyB0YXJnZXROb2RlIDogbnVsbCk7XG4gICAgICBzZWxmLmdyYXBoLmNoZWNrZWRPdXRSZWYoKS5ub2RlKHRhcmdldE5vZGUgPyB0YXJnZXROb2RlIDogbnVsbCk7XG4gICAgfSkuZmluYWxseShjYWxsYmFjayk7XG59XG5cbkdyYXBoQWN0aW9ucy5SZXZlcnQgPSBmdW5jdGlvbihncmFwaCwgbm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEdyYXBoQWN0aW9ucy5BY3Rpb25CYXNlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLnZpc2libGUgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi5wZXJmb3JtUHJvZ3Jlc3NCYXIucnVubmluZygpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc2VsZi5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCgpID09IHNlbGYubm9kZTtcbiAgfSk7XG59XG5pbmhlcml0cyhHcmFwaEFjdGlvbnMuUmV2ZXJ0LCBHcmFwaEFjdGlvbnMuQWN0aW9uQmFzZSk7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS50ZXh0ID0gJ1JldmVydCc7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS5zdHlsZSA9ICdyZXZlcnQnO1xuR3JhcGhBY3Rpb25zLlJldmVydC5wcm90b3R5cGUuaWNvbiA9ICdvY3RpY29uIG9jdGljb24taGlzdG9yeSc7XG5HcmFwaEFjdGlvbnMuUmV2ZXJ0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlcnZlci5wb3N0UHJvbWlzZSgnL3JldmVydCcsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBjb21taXQ6IHRoaXMubm9kZS5zaGExIH0pXG4gICAgLmZpbmFsbHkoY2FsbGJhY2spO1xufVxuIiwidmFyIGtvID0gcmVxdWlyZSgna25vY2tvdXQnKTtcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgndW5naXQtY29tcG9uZW50cycpO1xudmFyIFNlbGVjdGFibGUgPSByZXF1aXJlKCcuL3NlbGVjdGFibGUnKTtcbnZhciBBbmltYXRlYWJsZSA9IHJlcXVpcmUoJy4vYW5pbWF0ZWFibGUnKTtcbnZhciBwcm9ncmFtRXZlbnRzID0gcmVxdWlyZSgndW5naXQtcHJvZ3JhbS1ldmVudHMnKTtcbnZhciBHcmFwaEFjdGlvbnMgPSByZXF1aXJlKCcuL2dpdC1ncmFwaC1hY3Rpb25zJyk7XG5cbnZhciBHaXROb2RlVmlld01vZGVsID0gZnVuY3Rpb24oZ3JhcGgsIHNoYTEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBTZWxlY3RhYmxlLmNhbGwodGhpcywgZ3JhcGgpO1xuICBBbmltYXRlYWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMuc2hhMSA9IHNoYTE7XG4gIHRoaXMuaXNJbml0ZWQgPSBmYWxzZTtcbiAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnRzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuY29tbWl0VGltZSA9IHVuZGVmaW5lZDsgLy8gY29tbWl0IHRpbWUgaW4gc3RyaW5nXG4gIHRoaXMuZGF0ZSA9IHVuZGVmaW5lZDsgICAgICAgLy8gY29tbWl0IHRpbWUgaW4gbnVtZXJpYyBmb3JtYXQgZm9yIHNvcnRcbiAgdGhpcy5jb2xvciA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5pZGVvbG9naWNhbEJyYW5jaCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5yZW1vdGVUYWdzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MgPSBrby5vYnNlcnZhYmxlQXJyYXkoKTtcblxuICB0aGlzLnJlZnMgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICB2YXIgcnMgPSBzZWxmLmJyYW5jaGVzQW5kTG9jYWxUYWdzKCkuY29uY2F0KHNlbGYucmVtb3RlVGFncygpKTtcbiAgICBycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmlzTG9jYWwgJiYgIWIuaXNMb2NhbCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFhLmlzTG9jYWwgJiYgYi5pc0xvY2FsKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiBhLnJlZk5hbWUgPCBiLnJlZk5hbWUgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzO1xuICB9KTtcbiAgdGhpcy5hbmNlc3Rvck9mSEVBRCA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLm5vZGVJc01vdXNlaG92ZXIgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jb21taXRDb250YWluZXJWaXNpYmxlID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuYW5jZXN0b3JPZkhFQUQoKSB8fCBzZWxmLm5vZGVJc01vdXNlaG92ZXIoKSB8fCBzZWxmLnNlbGVjdGVkKCk7XG4gIH0pO1xuICB0aGlzLmhpZ2hsaWdodGVkID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYubm9kZUlzTW91c2Vob3ZlcigpIHx8IHNlbGYuc2VsZWN0ZWQoKTtcbiAgfSk7XG4gIHRoaXMuc2VsZWN0ZWQuc3Vic2NyaWJlKGZ1bmN0aW9uKCkge1xuICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ2dyYXBoLXJlbmRlcicgfSk7XG4gIH0pO1xuICB0aGlzLmNvbW1pdENvbXBvbmVudCA9IGNvbXBvbmVudHMuY3JlYXRlKCdjb21taXQnLCB7XG4gICAgc2hhMTogdGhpcy5zaGExLFxuICAgIHJlcG9QYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoLFxuICAgIHNlcnZlcjogdGhpcy5ncmFwaC5zZXJ2ZXIsXG4gICAgc2VsZWN0ZWQ6IHRoaXMuc2VsZWN0ZWQsXG4gICAgaGlnaGxpZ2h0ZWQ6IHRoaXMuaGlnaGxpZ2h0ZWQsXG4gICAgbm9kZUlzTW91c2Vob3ZlcjogdGhpcy5ub2RlSXNNb3VzZWhvdmVyXG4gIH0pO1xuICAvLyBUaGVzZSBhcmUgc3BsaXQgdXAgbGlrZSB0aGlzIGJlY2F1c2UgYnJhbmNoZXMgYW5kIGxvY2FsIHRhZ3MgY2FuIGJlIGZvdW5kIGluIHRoZSBnaXQgbG9nLFxuICAvLyB3aGVyZWFzIHJlbW90ZSB0YWdzIG5lZWRzIHRvIGJlIGZldGNoZWQgd2l0aCBhbm90aGVyIGNvbW1hbmQgKHdoaWNoIGlzIG11Y2ggc2xvd2VyKVxuICB0aGlzLmJyYW5jaGVzID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYucmVmcygpLmZpbHRlcihmdW5jdGlvbihyKSB7IHJldHVybiByLmlzQnJhbmNoOyB9KTtcbiAgfSk7XG4gIHRoaXMudGFncyA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLnJlZnMoKS5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gci5pc1RhZzsgfSk7XG4gIH0pO1xuICB0aGlzLnNob3dOZXdSZWZBY3Rpb24gPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIWdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIH0pO1xuICB0aGlzLm5ld0JyYW5jaE5hbWUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzID0ga28ub2JzZXJ2YWJsZSh0cnVlKTtcbiAgdGhpcy5uZXdCcmFuY2hOYW1lSGFzRm9jdXMuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgaWYgKCFuZXdWYWx1ZSkge1xuICAgICAgLy8gU21hbGwgdGltZW91dCBiZWNhdXNlIGluIGZmIHRoZSBmb3JtIGlzIGhpZGRlbiBiZWZvcmUgdGhlIHN1Ym1pdCBjbGljayBldmVudCBpcyByZWdpc3RlcmVkIG90aGVyd2lzZVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICB9LCAyMDApO1xuICAgIH1cbiAgfSk7XG4gIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jYW5DcmVhdGVSZWYgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5uZXdCcmFuY2hOYW1lKCkgJiYgc2VsZi5uZXdCcmFuY2hOYW1lKCkudHJpbSgpICYmIHNlbGYubmV3QnJhbmNoTmFtZSgpLmluZGV4T2YoJyAnKSA9PSAtMTtcbiAgfSk7XG4gIHRoaXMuYnJhbmNoT3JkZXIgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuYWJvdmVOb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLmJlbG93Tm9kZSA9IHVuZGVmaW5lZDtcblxuICB0aGlzLnIgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3ggPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuY3kgPSBrby5vYnNlcnZhYmxlKCk7XG5cbiAgdGhpcy5kcm9wYXJlYUdyYXBoQWN0aW9ucyA9IFtcbiAgICBuZXcgR3JhcGhBY3Rpb25zLk1vdmUodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZWJhc2UodGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5NZXJnZSh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlB1c2godGhpcy5ncmFwaCwgdGhpcyksXG4gICAgbmV3IEdyYXBoQWN0aW9ucy5SZXNldCh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLkNoZWNrb3V0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuRGVsZXRlKHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuQ2hlcnJ5UGljayh0aGlzLmdyYXBoLCB0aGlzKSxcbiAgICBuZXcgR3JhcGhBY3Rpb25zLlVuY29tbWl0KHRoaXMuZ3JhcGgsIHRoaXMpLFxuICAgIG5ldyBHcmFwaEFjdGlvbnMuUmV2ZXJ0KHRoaXMuZ3JhcGgsIHRoaXMpXG4gIF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IEdpdE5vZGVWaWV3TW9kZWw7XG5cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLmdldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW3RoaXMuY3goKSwgdGhpcy5jeSgpXTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNldEdyYXBoQXR0ciA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLmVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3gnLCB2YWxbMF0gLSAzMCk7XG4gIHRoaXMuZWxlbWVudCgpLnNldEF0dHJpYnV0ZSgneScsIHZhbFsxXSAtIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNJbml0ZWQpIHJldHVybjtcbiAgaWYgKHRoaXMuYW5jZXN0b3JPZkhFQUQoKSkge1xuICAgIHRoaXMucigzMCk7XG4gICAgdGhpcy5jeCg2MTApO1xuXG4gICAgaWYgKCF0aGlzLmFib3ZlTm9kZSkge1xuICAgICAgdGhpcy5jeSgxMjApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hYm92ZU5vZGUuYW5jZXN0b3JPZkhFQUQoKSkge1xuICAgICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZS5jeSgpICsgMTIwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZS5jeSgpICsgNjApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnIoMTUpO1xuICAgIHRoaXMuY3goNjEwICsgKDkwICogdGhpcy5icmFuY2hPcmRlcigpKSk7XG4gICAgdGhpcy5jeSh0aGlzLmFib3ZlTm9kZSA/IHRoaXMuYWJvdmVOb2RlLmN5KCkgKyA2MCA6IDEyMCk7XG4gIH1cblxuICBpZiAodGhpcy5hYm92ZU5vZGUgJiYgdGhpcy5hYm92ZU5vZGUuc2VsZWN0ZWQoKSkge1xuICAgIHRoaXMuY3kodGhpcy5hYm92ZU5vZGUuY3koKSArIHRoaXMuYWJvdmVOb2RlLmNvbW1pdENvbXBvbmVudC5lbGVtZW50KCkub2Zmc2V0SGVpZ2h0ICsgMzApO1xuICB9XG5cbiAgdGhpcy5jb21taXRDb21wb25lbnQuc2VsZWN0ZWREaWZmTGVmdFBvc2l0aW9uKC0odGhpcy5jeCgpIC0gNjAwKSk7XG4gIHRoaXMuY29sb3IodGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpID8gdGhpcy5pZGVvbG9naWNhbEJyYW5jaCgpLmNvbG9yIDogJyM2NjYnKTtcbiAgdGhpcy5hbmltYXRlKCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24obG9nRW50cnkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpdGxlID0gbG9nRW50cnkubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG4gIHRoaXMucGFyZW50cyhsb2dFbnRyeS5wYXJlbnRzIHx8IFtdKTtcbiAgdGhpcy5jb21taXRUaW1lID0gbG9nRW50cnkuY29tbWl0RGF0ZTtcbiAgdGhpcy5kYXRlID0gRGF0ZS5wYXJzZSh0aGlzLmNvbW1pdFRpbWUpO1xuICB0aGlzLmNvbW1pdENvbXBvbmVudC5zZXREYXRhKGxvZ0VudHJ5KTtcblxuICBpZiAobG9nRW50cnkucmVmcykge1xuICAgIGxvZ0VudHJ5LnJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICAgIHNlbGYuZ3JhcGguZ2V0UmVmKHJlZikubm9kZShzZWxmKTtcbiAgICB9KTtcbiAgfVxuICB0aGlzLmlzSW5pdGVkID0gdHJ1ZTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnNob3dCcmFuY2hpbmdGb3JtID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnJhbmNoaW5nRm9ybVZpc2libGUodHJ1ZSk7XG4gIHRoaXMubmV3QnJhbmNoTmFtZUhhc0ZvY3VzKHRydWUpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjb21tYW5kID0gdW5naXQuY29uZmlnLmF1dG9DaGVja291dE9uQnJhbmNoQ3JlYXRlID8gXCIvY2hlY2tvdXRcIiA6IFwiL2JyYW5jaGVzXCI7XG5cbiAgdGhpcy5ncmFwaC5zZXJ2ZXIucG9zdFByb21pc2UoY29tbWFuZCwgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMubmV3QnJhbmNoTmFtZSgpLCBzaGExOiB0aGlzLnNoYTEgfSlcbiAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZ3JhcGguZ2V0UmVmKCdyZWZzL2hlYWRzLycgKyBzZWxmLm5ld0JyYW5jaE5hbWUoKSkubm9kZShzZWxmKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICBzZWxmLm5ld0JyYW5jaE5hbWUoJycpO1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnYnJhbmNoLXVwZGF0ZWQnIH0pO1xuICAgIH0pO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW5DcmVhdGVSZWYoKSkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ3JhcGguc2VydmVyLnBvc3RQcm9taXNlKCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLm5ld0JyYW5jaE5hbWUoKSwgc2hhMTogdGhpcy5zaGExIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3UmVmID0gc2VsZi5ncmFwaC5nZXRSZWYoJ3RhZzogcmVmcy90YWdzLycgKyBzZWxmLm5ld0JyYW5jaE5hbWUoKSk7XG4gICAgICBuZXdSZWYubm9kZShzZWxmKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5icmFuY2hpbmdGb3JtVmlzaWJsZShmYWxzZSk7XG4gICAgICBzZWxmLm5ld0JyYW5jaE5hbWUoJycpO1xuICAgIH0pO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUudG9nZ2xlU2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYmVmb3JlVGhpc0NSID0gdGhpcy5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgYmVmb3JlQmVsb3dDUiA9IG51bGw7XG4gIGlmICh0aGlzLmJlbG93Tm9kZSkge1xuICAgIGJlZm9yZUJlbG93Q1IgPSB0aGlzLmJlbG93Tm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgdmFyIHByZXZTZWxlY3RlZCAgPSB0aGlzLmdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gIGlmICghKHByZXZTZWxlY3RlZCBpbnN0YW5jZW9mIEdpdE5vZGVWaWV3TW9kZWwpKSBwcmV2U2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgcHJldlNlbGVjdGVkQ1IgPSBwcmV2U2VsZWN0ZWQgPyBwcmV2U2VsZWN0ZWQuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gIHRoaXMuc2VsZWN0ZWQoIXRoaXMuc2VsZWN0ZWQoKSk7XG5cbiAgLy8gSWYgd2UgYXJlIGRlc2VsZWN0aW5nXG4gIGlmICghdGhpcy5zZWxlY3RlZCgpKSB7XG4gICAgaWYgKGJlZm9yZVRoaXNDUi50b3AgPCAwICYmIGJlZm9yZUJlbG93Q1IpIHtcbiAgICAgIHZhciBhZnRlckJlbG93Q1IgPSB0aGlzLmJlbG93Tm9kZS5jb21taXRDb21wb25lbnQuZWxlbWVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBzaG93aW5nLCB0cnkgdG8ga2VlcCBpdCBpbiB0aGUgc2NyZWVuIChubyBqdW1waW5nKVxuICAgICAgaWYgKGJlZm9yZUJlbG93Q1IudG9wIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCBhZnRlckJlbG93Q1IudG9wIC0gYmVmb3JlQmVsb3dDUi50b3ApO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgdHJ5IHRvIGJyaW5nIHRoZW0gdG8gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgYWZ0ZXJCZWxvd0NSLnRvcCAtIHdpbmRvdy5pbm5lckhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgLy8gSWYgd2UgYXJlIHNlbGVjdGluZ1xuICB9IGVsc2Uge1xuICAgIHZhciBhZnRlclRoaXNDUiA9IHRoaXMuY29tbWl0Q29tcG9uZW50LmVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoKHByZXZTZWxlY3RlZENSICYmIChwcmV2U2VsZWN0ZWRDUi50b3AgPCAwIHx8IHByZXZTZWxlY3RlZENSLnRvcCA+IHdpbmRvdy5pbm5lckhlaWdodCkpICYmXG4gICAgICBhZnRlclRoaXNDUi50b3AgIT0gYmVmb3JlVGhpc0NSLnRvcCkge1xuICAgICAgd2luZG93LnNjcm9sbEJ5KDAsIC0oYmVmb3JlVGhpc0NSLnRvcCAtIGFmdGVyVGhpc0NSLnRvcCkpO1xuICAgICAgY29uc29sZS5sb2coJ0ZpeCcpXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnJlbW92ZVJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICBpZiAocmVmLmlzUmVtb3RlVGFnKSB7XG4gICAgdGhpcy5yZW1vdGVUYWdzLnJlbW92ZShyZWYpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnJhbmNoZXNBbmRMb2NhbFRhZ3MucmVtb3ZlKHJlZik7XG4gIH1cbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLnB1c2hSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYgKHJlZi5pc1JlbW90ZVRhZyAmJiB0aGlzLnJlbW90ZVRhZ3MuaW5kZXhPZihyZWYpIDwgMCkge1xuICAgIHRoaXMucmVtb3RlVGFncy5wdXNoKHJlZik7XG4gIH0gZWxzZSBpZih0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICB0aGlzLmJyYW5jaGVzQW5kTG9jYWxUYWdzLnB1c2gocmVmKTtcbiAgfVxufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UGF0aFRvQ29tbW9uQW5jZXN0b3IgPSBmdW5jdGlvbihub2RlKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHZhciB0aGlzTm9kZSA9IHRoaXM7XG4gIHdoaWxlICh0aGlzTm9kZSAmJiAhbm9kZS5pc0FuY2VzdG9yKHRoaXNOb2RlKSkge1xuICAgIHBhdGgucHVzaCh0aGlzTm9kZSk7XG4gICAgdGhpc05vZGUgPSB0aGlzLmdyYXBoLm5vZGVzQnlJZFt0aGlzTm9kZS5wYXJlbnRzKClbMF1dO1xuICB9XG4gIGlmICh0aGlzTm9kZSkgcGF0aC5wdXNoKHRoaXNOb2RlKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5pc0FuY2VzdG9yID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAobm9kZSA9PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgdiBpbiB0aGlzLnBhcmVudHMoKSkge1xuICAgIHZhciBuID0gdGhpcy5ncmFwaC5ub2Rlc0J5SWRbdGhpcy5wYXJlbnRzKClbdl1dO1xuICAgIGlmIChuICYmIG4uaXNBbmNlc3Rvcihub2RlKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmlnaHRUb0xlZnRTdHJpa2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICdNICcgKyAodGhpcy5jeCgpIC0gMzApICsgJyAnICsgKHRoaXMuY3koKSAtIDMwKSArICcgTCAnICsgKHRoaXMuY3goKSArIDMwKSArICcgJyArICh0aGlzLmN5KCkgKyAzMCk7XG59XG5HaXROb2RlVmlld01vZGVsLnByb3RvdHlwZS5nZXRMZWZ0VG9SaWdodFN0cmlrZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJ00gJyArICh0aGlzLmN4KCkgKyAzMCkgKyAnICcgKyAodGhpcy5jeSgpIC0gMzApICsgJyBMICcgKyAodGhpcy5jeCgpIC0gMzApICsgJyAnICsgKHRoaXMuY3koKSArIDMwKTtcbn1cbkdpdE5vZGVWaWV3TW9kZWwucHJvdG90eXBlLm5vZGVNb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub2RlSXNNb3VzZWhvdmVyKHRydWUpO1xufVxuR2l0Tm9kZVZpZXdNb2RlbC5wcm90b3R5cGUubm9kZU1vdXNlb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMubm9kZUlzTW91c2Vob3ZlcihmYWxzZSk7XG59XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xudmFyIG1kNSA9IHJlcXVpcmUoJ2JsdWVpbXAtbWQ1Jyk7XG52YXIgU2VsZWN0YWJsZSA9IHJlcXVpcmUoJy4vc2VsZWN0YWJsZScpO1xudmFyIHByb2dyYW1FdmVudHMgPSByZXF1aXJlKCd1bmdpdC1wcm9ncmFtLWV2ZW50cycpO1xudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCd1bmdpdC1jb21wb25lbnRzJyk7XG5cbnZhciBSZWZWaWV3TW9kZWwgPSBmdW5jdGlvbihmdWxsUmVmTmFtZSwgZ3JhcGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBTZWxlY3RhYmxlLmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMubmFtZSA9IGZ1bGxSZWZOYW1lO1xuICB0aGlzLm5vZGUgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lOyAvLyBvcmlnaW4vbWFzdGVyIG9yIG1hc3RlclxuICB0aGlzLnJlZk5hbWUgPSB0aGlzLm5hbWU7IC8vIG1hc3RlclxuICB0aGlzLmlzUmVtb3RlVGFnID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlbW90ZS10YWc6ICcpID09IDA7XG4gIHRoaXMuaXNMb2NhbFRhZyA9IHRoaXMubmFtZS5pbmRleE9mKCd0YWc6ICcpID09IDA7XG4gIHRoaXMuaXNUYWcgPSB0aGlzLmlzTG9jYWxUYWcgfHwgdGhpcy5pc1JlbW90ZVRhZztcbiAgdmFyIGlzUmVtb3RlQnJhbmNoT3JIRUFEID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvcmVtb3Rlcy8nKSA9PSAwO1xuICB0aGlzLmlzTG9jYWxIRUFEID0gdGhpcy5uYW1lID09ICdIRUFEJztcbiAgdGhpcy5pc1JlbW90ZUhFQUQgPSB0aGlzLm5hbWUuaW5kZXhPZignL0hFQUQnKSAhPSAtMTtcbiAgdGhpcy5pc0xvY2FsQnJhbmNoID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvaGVhZHMvJykgPT0gMDtcbiAgdGhpcy5pc1JlbW90ZUJyYW5jaCA9IGlzUmVtb3RlQnJhbmNoT3JIRUFEICYmICF0aGlzLmlzUmVtb3RlSEVBRDtcbiAgdGhpcy5pc1N0YXNoID0gdGhpcy5uYW1lLmluZGV4T2YoJ3JlZnMvc3Rhc2gnKSA9PSAwO1xuICB0aGlzLmlzSEVBRCA9IHRoaXMuaXNMb2NhbEhFQUQgfHwgdGhpcy5pc1JlbW90ZUhFQUQ7XG4gIHRoaXMuaXNCcmFuY2ggPSB0aGlzLmlzTG9jYWxCcmFuY2ggfHwgdGhpcy5pc1JlbW90ZUJyYW5jaDtcbiAgdGhpcy5pc1JlbW90ZSA9IGlzUmVtb3RlQnJhbmNoT3JIRUFEIHx8IHRoaXMuaXNSZW1vdGVUYWc7XG4gIHRoaXMuaXNMb2NhbCA9IHRoaXMuaXNMb2NhbEJyYW5jaCB8fCB0aGlzLmlzTG9jYWxUYWc7XG4gIGlmICh0aGlzLmlzTG9jYWxCcmFuY2gpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVmcy9oZWFkcy8nLmxlbmd0aCk7XG4gICAgdGhpcy5yZWZOYW1lID0gdGhpcy5sb2NhbFJlZk5hbWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNSZW1vdGVCcmFuY2gpIHtcbiAgICB0aGlzLmxvY2FsUmVmTmFtZSA9IHRoaXMubmFtZS5zbGljZSgncmVmcy9yZW1vdGVzLycubGVuZ3RoKTtcbiAgfVxuICBpZiAodGhpcy5pc0xvY2FsVGFnKSB7XG4gICAgdGhpcy5sb2NhbFJlZk5hbWUgPSB0aGlzLm5hbWUuc2xpY2UoJ3RhZzogcmVmcy90YWdzLycubGVuZ3RoKTtcbiAgICB0aGlzLnJlZk5hbWUgPSB0aGlzLmxvY2FsUmVmTmFtZTtcbiAgfVxuICBpZiAodGhpcy5pc1JlbW90ZVRhZykge1xuICAgIHRoaXMubG9jYWxSZWZOYW1lID0gdGhpcy5uYW1lLnNsaWNlKCdyZW1vdGUtdGFnOiAnLmxlbmd0aCk7XG4gIH1cbiAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBvcmlnaW4vIHBhcnQgb2Ygb3JpZ2luL2JyYW5jaG5hbWVcbiAgICB2YXIgcyA9IHRoaXMubG9jYWxSZWZOYW1lLnNwbGl0KCcvJyk7XG4gICAgdGhpcy5yZW1vdGUgPSBzWzBdO1xuICAgIHRoaXMucmVmTmFtZSA9IHMuc2xpY2UoMSkuam9pbignLycpO1xuICB9XG4gIHRoaXMuc2hvdyA9IHRydWU7XG4gIHRoaXMuc2VydmVyID0gdGhpcy5ncmFwaC5zZXJ2ZXI7XG4gIHRoaXMuaXNEcmFnZ2luZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpO1xuICB0aGlzLmN1cnJlbnQgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5pc0xvY2FsQnJhbmNoICYmIHNlbGYuZ3JhcGguY2hlY2tlZE91dEJyYW5jaCgpID09IHNlbGYucmVmTmFtZTtcbiAgfSk7XG4gIHRoaXMuY29sb3IgPSB0aGlzLl9jb2xvckZyb21IYXNoT2ZTdHJpbmcodGhpcy5uYW1lKTtcblxuICB0aGlzLm5vZGUuc3Vic2NyaWJlKGZ1bmN0aW9uKG9sZE5vZGUpIHtcbiAgICBpZiAob2xkTm9kZSkgb2xkTm9kZS5yZW1vdmVSZWYoc2VsZik7XG4gIH0sIG51bGwsIFwiYmVmb3JlQ2hhbmdlXCIpO1xuICB0aGlzLm5vZGUuc3Vic2NyaWJlKGZ1bmN0aW9uKG5ld05vZGUpIHtcbiAgICBpZiAobmV3Tm9kZSkgbmV3Tm9kZS5wdXNoUmVmKHNlbGYpO1xuICB9KTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFJlZlZpZXdNb2RlbDtcblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5fY29sb3JGcm9tSGFzaE9mU3RyaW5nID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiAnIycgKyBtZDUoc3RyaW5nKS50b1N0cmluZygpLnNsaWNlKDAsIDYpO1xufVxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5kcmFnU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgdGhpcy5pc0RyYWdnaW5nKHRydWUpO1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG59XG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmRyYWdFbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dChudWxsKTtcbiAgdGhpcy5pc0RyYWdnaW5nKGZhbHNlKTtcbn1cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24odGFyZ2V0LCBjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdmFyIGNhbGxiYWNrV2l0aFJlZlNldCA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHNlbGYuZ3JhcGguZ2V0Tm9kZSh0YXJnZXQpO1xuICAgICAgaWYgKHNlbGYuZ3JhcGguY2hlY2tlZE91dEJyYW5jaCgpID09IHNlbGYucmVmTmFtZSkge1xuICAgICAgICBzZWxmLmdyYXBoLkhFQURyZWYoKS5ub2RlKHRhcmdldE5vZGUpO1xuICAgICAgfVxuICAgICAgc2VsZi5ub2RlKHRhcmdldE5vZGUpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5pc0xvY2FsKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCgpKSB7XG4gICAgICB0aGlzLnNlcnZlci5wb3N0KCcvcmVzZXQnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgdG86IHRhcmdldCwgbW9kZTogJ2hhcmQnIH0sIGNhbGxiYWNrV2l0aFJlZlNldCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVGFnKSB7XG4gICAgICB0aGlzLnNlcnZlci5wb3N0KCcvdGFncycsIHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCBuYW1lOiB0aGlzLnJlZk5hbWUsIHNoYTE6IHRhcmdldCwgZm9yY2U6IHRydWUgfSwgY2FsbGJhY2tXaXRoUmVmU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXJ2ZXIucG9zdCgnL2JyYW5jaGVzJywgeyBwYXRoOiB0aGlzLmdyYXBoLnJlcG9QYXRoKCksIG5hbWU6IHRoaXMucmVmTmFtZSwgc2hhMTogdGFyZ2V0LCBmb3JjZTogdHJ1ZSB9LCBjYWxsYmFja1dpdGhSZWZTZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHVzaFJlcSA9IHsgcGF0aDogdGhpcy5ncmFwaC5yZXBvUGF0aCgpLCByZW1vdGU6IHRoaXMucmVtb3RlLCByZWZTcGVjOiB0YXJnZXQsIHJlbW90ZUJyYW5jaDogdGhpcy5yZWZOYW1lIH07XG4gICAgdGhpcy5zZXJ2ZXIucG9zdCgnL3B1c2gnLCBwdXNoUmVxLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5lcnJvckNvZGUgPT0gJ25vbi1mYXN0LWZvcndhcmQnKSB7XG4gICAgICAgICAgICB2YXIgZm9yY2VQdXNoRGlhbG9nID0gY29tcG9uZW50cy5jcmVhdGUoJ3llc25vZGlhbG9nJywgeyB0aXRsZTogJ0ZvcmNlIHB1c2g/JywgZGV0YWlsczogJ1RoZSByZW1vdGUgYnJhbmNoIGNhblxcJ3QgYmUgZmFzdC1mb3J3YXJkZWQuJyB9KTtcbiAgICAgICAgICAgIGZvcmNlUHVzaERpYWxvZy5jbG9zZWQuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoIWZvcmNlUHVzaERpYWxvZy5yZXN1bHQoKSkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHB1c2hSZXEuZm9yY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxmLnNlcnZlci5wb3N0KCcvcHVzaCcsIHB1c2hSZXEsIGNhbGxiYWNrV2l0aFJlZlNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2dyYW1FdmVudHMuZGlzcGF0Y2goeyBldmVudDogJ3JlcXVlc3Qtc2hvdy1kaWFsb2cnLCBkaWFsb2c6IGZvcmNlUHVzaERpYWxvZyB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFja1dpdGhSZWZTZXQoZXJyLCByZXMpO1xuICAgICAgfSk7XG4gIH1cbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB0aGlzLmlzVGFnID8gJy90YWdzJyA6ICcvYnJhbmNoZXMnO1xuICBpZiAodGhpcy5pc1JlbW90ZSkgdXJsID0gJy9yZW1vdGUnICsgdXJsO1xuICB0aGlzLnNlcnZlci5kZWwodXJsLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLmlzUmVtb3RlID8gdGhpcy5yZW1vdGUgOiBudWxsLCBuYW1lOiB0aGlzLnJlZk5hbWUgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHNlbGYubm9kZSgpLnJlbW92ZVJlZihzZWxmKTtcbiAgICAgIHNlbGYuZ3JhcGgucmVmc0J5UmVmTmFtZVtzZWxmLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gICAgc2VsZi5ncmFwaC5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gICAgaWYgKHVybCA9PSAnL3JlbW90ZS90YWdzJykge1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAncmVxdWVzdC1mZXRjaC10YWdzJyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvZ3JhbUV2ZW50cy5kaXNwYXRjaCh7IGV2ZW50OiAnYnJhbmNoLXVwZGF0ZWQnIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cblJlZlZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVtb3RlUmVmID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoLmdldFJlZih0aGlzLmdldFJlbW90ZVJlZkZ1bGxOYW1lKHJlbW90ZSksIGZhbHNlKTtcbn1cblxuUmVmVmlld01vZGVsLnByb3RvdHlwZS5nZXRSZW1vdGVSZWZGdWxsTmFtZSA9IGZ1bmN0aW9uKHJlbW90ZSkge1xuICBpZiAodGhpcy5pc0xvY2FsQnJhbmNoKSByZXR1cm4gJ3JlZnMvcmVtb3Rlcy8nICsgcmVtb3RlICsgJy8nICsgdGhpcy5yZWZOYW1lO1xuICBpZiAodGhpcy5pc0xvY2FsVGFnKSByZXR1cm4gJ3JlbW90ZS10YWc6ICcgKyByZW1vdGUgKyAnLycgKyB0aGlzLnJlZk5hbWU7XG4gIHJldHVybiBudWxsO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNhbkJlUHVzaGVkID0gZnVuY3Rpb24ocmVtb3RlKSB7XG4gIGlmICghdGhpcy5pc0xvY2FsKSByZXR1cm4gZmFsc2U7XG4gIHZhciByZW1vdGVSZWYgPSB0aGlzLmdldFJlbW90ZVJlZihyZW1vdGUpO1xuICBpZiAoIXJlbW90ZVJlZikgcmV0dXJuIHRydWU7XG4gIHJldHVybiB0aGlzLm5vZGUoKSAhPSByZW1vdGVSZWYubm9kZSgpO1xufVxuXG5SZWZWaWV3TW9kZWwucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVJlZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5zZXJ2ZXIucG9zdCgnL3B1c2gnLCB7IHBhdGg6IHRoaXMuZ3JhcGgucmVwb1BhdGgoKSwgcmVtb3RlOiB0aGlzLmdyYXBoLmN1cnJlbnRSZW1vdGUoKSxcbiAgICAgIHJlZlNwZWM6IHRoaXMucmVmTmFtZSwgcmVtb3RlQnJhbmNoOiB0aGlzLnJlZk5hbWUgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdmFyIG5ld1JlZiA9IHNlbGYuZ3JhcGguZ2V0UmVmKFwicmVmcy9yZW1vdGVzL1wiICsgc2VsZi5ncmFwaC5jdXJyZW50UmVtb3RlKCkgKyBcIi9cIiArIHNlbGYucmVmTmFtZSk7XG4gICAgICAgICAgbmV3UmVmLm5vZGUoc2VsZi5ub2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbn1cbiIsInZhciBrbyA9IHJlcXVpcmUoJ2tub2Nrb3V0Jyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJ3VuZ2l0LWNvbXBvbmVudHMnKTtcbnZhciBHaXROb2RlVmlld01vZGVsID0gcmVxdWlyZSgnLi9naXQtbm9kZScpO1xudmFyIEdpdFJlZlZpZXdNb2RlbCA9IHJlcXVpcmUoJy4vZ2l0LXJlZicpO1xudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbnZhciBFZGdlVmlld01vZGVsID0gcmVxdWlyZSgnLi9lZGdlJyk7XG5cbmNvbXBvbmVudHMucmVnaXN0ZXIoJ2dyYXBoJywgZnVuY3Rpb24oYXJncykge1xuICByZXR1cm4gbmV3IEdyYXBoVmlld01vZGVsKGFyZ3Muc2VydmVyLCBhcmdzLnJlcG9QYXRoKTtcbn0pO1xuXG5mdW5jdGlvbiBHcmFwaFZpZXdNb2RlbChzZXJ2ZXIsIHJlcG9QYXRoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZXBvUGF0aCA9IHJlcG9QYXRoO1xuICB0aGlzLm1heE5Ob2RlcyA9IDI1O1xuICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgdGhpcy5jdXJyZW50UmVtb3RlID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLm5vZGVzTG9hZGVyID0gY29tcG9uZW50cy5jcmVhdGUoJ3Byb2dyZXNzQmFyJywge1xuICAgIHByZWRpY3Rpb25NZW1vcnlLZXk6ICdnaXRncmFwaC0nICsgc2VsZi5yZXBvUGF0aCgpLFxuICAgIGZhbGxiYWNrUHJlZGljdGVkVGltZU1zOiAxMDAwLFxuICAgIHRlbXBvcmFyeTogdHJ1ZVxuICB9KTtcbiAgdGhpcy5ub2RlcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLmVkZ2VzID0ga28ub2JzZXJ2YWJsZUFycmF5KCk7XG4gIHRoaXMucmVmcyA9IGtvLm9ic2VydmFibGVBcnJheSgpO1xuICB0aGlzLm5vZGVzQnlJZCA9IHt9O1xuICB0aGlzLnJlZnNCeVJlZk5hbWUgPSB7fTtcbiAgdGhpcy5jaGVja2VkT3V0QnJhbmNoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmNoZWNrZWRPdXRSZWYgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5jaGVja2VkT3V0QnJhbmNoKCkgPyBzZWxmLmdldFJlZigncmVmcy9oZWFkcy8nICsgc2VsZi5jaGVja2VkT3V0QnJhbmNoKCkpIDogbnVsbDtcbiAgfSk7XG4gIHRoaXMuSEVBRHJlZiA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5IRUFEID0ga28uY29tcHV0ZWQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuSEVBRHJlZigpID8gc2VsZi5IRUFEcmVmKCkubm9kZSgpIDogdW5kZWZpbmVkO1xuICB9KTtcbiAgdGhpcy5jb21taXROb2RlQ29sb3IgPSBrby5jb21wdXRlZChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5IRUFEKCkgPyBzZWxmLkhFQUQoKS5jb2xvcigpIDogJyM0QTRBNEEnO1xuICB9KTtcbiAgdGhpcy5jb21taXROb2RlRWRnZSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5IRUFEKCkgfHwgIXNlbGYuSEVBRCgpLmN4KCkgfHwgIXNlbGYuSEVBRCgpLmN5KCkpIHJldHVybjtcbiAgICByZXR1cm4gXCJNIDYxMCA2OCBMIFwiICsgc2VsZi5IRUFEKCkuY3goKSArIFwiIFwiICsgc2VsZi5IRUFEKCkuY3koKTtcbiAgfSk7XG4gIHRoaXMuc2hvd0NvbW1pdE5vZGUgPSBrby5vYnNlcnZhYmxlKGZhbHNlKTtcbiAgdGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCA9IGtvLm9ic2VydmFibGUoKTtcbiAgdGhpcy5lZGdlc0J5SWQgPSB7fTtcbiAgdGhpcy5zY3JvbGxlZFRvRW5kID0gXy5kZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICBzZWxmLm1heE5Ob2RlcyA9IHNlbGYubWF4Tk5vZGVzICsgMjU7XG4gICAgc2VsZi5sb2FkTm9kZXNGcm9tQXBpKCk7XG4gIH0sIDUwMCwgdHJ1ZSk7XG4gIHRoaXMuZGltQ29tbWl0ID0ga28ub2JzZXJ2YWJsZShmYWxzZSk7XG4gIHRoaXMuY29tbWl0T3BhY2l0eSA9IGtvLmNvbXB1dGVkKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5kaW1Db21taXQoKSA/IDAuMSA6IDE7IH0pO1xuICB0aGlzLmhlaWdoc3RCcmFuY2hPcmRlciA9IDA7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMgPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbkdyYXBoaWMuc3Vic2NyaWJlKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmRlc3Ryb3kpXG4gICAgICB2YWx1ZS5kZXN0cm95KCk7XG4gIH0sIG51bGwsICdiZWZvcmVDaGFuZ2UnKTtcblxuICB0aGlzLmhvdmVyR3JhcGhBY3Rpb24gPSBrby5vYnNlcnZhYmxlKCk7XG4gIHRoaXMuaG92ZXJHcmFwaEFjdGlvbi5zdWJzY3JpYmUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUuY3JlYXRlSG92ZXJHcmFwaGljKSB7XG4gICAgICBzZWxmLmhvdmVyR3JhcGhBY3Rpb25HcmFwaGljKHZhbHVlLmNyZWF0ZUhvdmVyR3JhcGhpYygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5ob3ZlckdyYXBoQWN0aW9uR3JhcGhpYyhudWxsKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMubG9hZE5vZGVzRnJvbUFwaVRocm90dGxlZCA9IF8udGhyb3R0bGUodGhpcy5sb2FkTm9kZXNGcm9tQXBpLmJpbmQodGhpcyksIDUwMCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQgPSBfLnRocm90dGxlKHRoaXMudXBkYXRlQnJhbmNoZXMuYmluZCh0aGlzKSwgNTAwKTtcbiAgdGhpcy5sb2FkTm9kZXNGcm9tQXBpVGhyb3R0bGVkKCk7XG4gIHRoaXMudXBkYXRlQnJhbmNoZXNUaHJvdHRsZWQoKTtcbiAgdGhpcy5ncmFwaFdpZHRoID0ga28ub2JzZXJ2YWJsZSgpO1xuICB0aGlzLmdyYXBoSGVpZ2h0ID0ga28ub2JzZXJ2YWJsZSgpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUudXBkYXRlTm9kZSA9IGZ1bmN0aW9uKHBhcmVudEVsZW1lbnQpIHtcbiAga28ucmVuZGVyVGVtcGxhdGUoJ2dyYXBoJywgdGhpcywge30sIHBhcmVudEVsZW1lbnQpO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uKHNoYTEsIGxvZ0VudHJ5KSB7XG4gIHZhciBub2RlVmlld01vZGVsID0gdGhpcy5ub2Rlc0J5SWRbc2hhMV07XG4gIGlmICghbm9kZVZpZXdNb2RlbCkgbm9kZVZpZXdNb2RlbCA9IHRoaXMubm9kZXNCeUlkW3NoYTFdID0gbmV3IEdpdE5vZGVWaWV3TW9kZWwodGhpcywgc2hhMSk7XG4gIGlmIChsb2dFbnRyeSkgbm9kZVZpZXdNb2RlbC5zZXREYXRhKGxvZ0VudHJ5KTtcbiAgcmV0dXJuIG5vZGVWaWV3TW9kZWw7XG59XG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24ocmVmLCBjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlKSB7XG4gIGlmIChjb25zdHJ1Y3RJZlVuYXZhaWxhYmxlID09PSB1bmRlZmluZWQpIGNvbnN0cnVjdElmVW5hdmFpbGFibGUgPSB0cnVlO1xuICB2YXIgcmVmVmlld01vZGVsID0gdGhpcy5yZWZzQnlSZWZOYW1lW3JlZl07XG4gIGlmICghcmVmVmlld01vZGVsICYmIGNvbnN0cnVjdElmVW5hdmFpbGFibGUpIHtcbiAgICByZWZWaWV3TW9kZWwgPSB0aGlzLnJlZnNCeVJlZk5hbWVbcmVmXSA9IG5ldyBHaXRSZWZWaWV3TW9kZWwocmVmLCB0aGlzKTtcbiAgICB0aGlzLnJlZnMucHVzaChyZWZWaWV3TW9kZWwpO1xuICAgIGlmIChyZWZWaWV3TW9kZWwubmFtZSA9PT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLkhFQURyZWYocmVmVmlld01vZGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZlZpZXdNb2RlbDtcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmxvYWROb2Rlc0Zyb21BcGkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5ub2Rlc0xvYWRlci5zdGFydCgpO1xuICB0aGlzLnNlcnZlci5nZXRQcm9taXNlKCcvbG9nJywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCksIGxpbWl0OiB0aGlzLm1heE5Ob2RlcyB9KVxuICAgIC50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICBub2RlcyA9IHNlbGYuY29tcHV0ZU5vZGUobm9kZXMubWFwKGZ1bmN0aW9uKGxvZ0VudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0Tm9kZShsb2dFbnRyeS5zaGExLCBsb2dFbnRyeSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgdmFyIGVkZ2VzID0gW107XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnRzKCkuZm9yRWFjaChmdW5jdGlvbihwYXJlbnRTaGExKSB7XG4gICAgICAgICAgZWRnZXMucHVzaChzZWxmLmdldEVkZ2Uobm9kZS5zaGExLCBwYXJlbnRTaGExKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlLnJlbmRlcigpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuZWRnZXMoZWRnZXMpO1xuICAgICAgc2VsZi5ub2Rlcyhub2Rlcyk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGYuZ3JhcGhIZWlnaHQobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uY3koKSArIDgwKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZ3JhcGhXaWR0aCgxMDAwICsgKHNlbGYuaGVpZ2hzdEJyYW5jaE9yZGVyICogOTApKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5ub2Rlc0xvYWRlci5zdG9wKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfSk7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyA9IGZ1bmN0aW9uKG5vZGUsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG5vZGUpO1xuICB2YXIgcGFyZW50ID0gdGhpcy5ub2Rlc0J5SWRbbm9kZS5wYXJlbnRzKClbMF1dO1xuICBpZiAocGFyZW50KSB7XG4gICAgdGhpcy50cmF2ZXJzZU5vZGVMZWZ0UGFyZW50cyhwYXJlbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuY29tcHV0ZU5vZGUgPSBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFub2Rlcykge1xuICAgIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB9XG5cbiAgdGhpcy5tYXJrTm9kZXNJZGVvbG9naWNhbEJyYW5jaGVzKHRoaXMucmVmcygpLCBub2RlcywgdGhpcy5ub2Rlc0J5SWQpO1xuXG4gIHZhciB1cGRhdGVUaW1lU3RhbXAgPSBtb21lbnQoKS52YWx1ZU9mKCk7XG4gIGlmICh0aGlzLkhFQUQoKSkge1xuICAgIHRoaXMudHJhdmVyc2VOb2RlTGVmdFBhcmVudHModGhpcy5IRUFEKCksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPSB1cGRhdGVUaW1lU3RhbXA7XG4gICAgfSk7XG4gIH1cblxuICAvLyBGaWx0ZXIgb3V0IG5vZGVzIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIGJyYW5jaCAoc3RhZ2luZyBhbmQgb3JwaGFuZWQgbm9kZXMpXG4gIG5vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG5vZGUpIHsgcmV0dXJuIChub2RlLmlkZW9sb2dpY2FsQnJhbmNoKCkgJiYgIW5vZGUuaWRlb2xvZ2ljYWxCcmFuY2goKS5pc1N0YXNoKSB8fCBub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcDsgfSlcblxuICB2YXIgYnJhbmNoU2xvdHMgPSBbXTtcblxuICAvLyBUaGVuIGl0ZXJhdGUgZnJvbSB0aGUgYm90dG9tIHRvIGZpeCB0aGUgb3JkZXJzIG9mIHRoZSBicmFuY2hlc1xuICBmb3IgKHZhciBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmFuY2VzdG9yT2ZIRUFEVGltZVN0YW1wID09IHVwZGF0ZVRpbWVTdGFtcCkgY29udGludWU7XG4gICAgdmFyIGlkZW9sb2dpY2FsQnJhbmNoID0gbm9kZS5pZGVvbG9naWNhbEJyYW5jaCgpO1xuXG4gICAgLy8gRmlyc3Qgb2NjdXJlbmNlIG9mIHRoZSBicmFuY2gsIGZpbmQgYW4gZW1wdHkgc2xvdCBmb3IgdGhlIGJyYW5jaFxuICAgIGlmIChpZGVvbG9naWNhbEJyYW5jaC5sYXN0U2xvdHRlZFRpbWVTdGFtcCAhPSB1cGRhdGVUaW1lU3RhbXApIHtcbiAgICAgIGlkZW9sb2dpY2FsQnJhbmNoLmxhc3RTbG90dGVkVGltZVN0YW1wID0gdXBkYXRlVGltZVN0YW1wO1xuICAgICAgdmFyIHNsb3QgPSBicmFuY2hTbG90cy5pbmRleE9mKHVuZGVmaW5lZCk7XG4gICAgICBpZiAoc2xvdCA9PT0gLTEpIHtcbiAgICAgICAgYnJhbmNoU2xvdHMucHVzaChpZGVvbG9naWNhbEJyYW5jaCk7XG4gICAgICAgIHNsb3QgPSBicmFuY2hTbG90cy5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXIgPSBzbG90O1xuICAgICAgYnJhbmNoU2xvdHNbc2xvdF0gPSBzbG90O1xuICAgIH1cblxuICAgIG5vZGUuYnJhbmNoT3JkZXIoaWRlb2xvZ2ljYWxCcmFuY2guYnJhbmNoT3JkZXIpO1xuICAgIHNlbGYuaGVpZ2hzdEJyYW5jaE9yZGVyID0gTWF0aC5tYXgoc2VsZi5oZWlnaHN0QnJhbmNoT3JkZXIsIG5vZGUuYnJhbmNoT3JkZXIoKSk7XG4gIH1cblxuICB2YXIgcHJldk5vZGU7XG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuYnJhbmNoT3JkZXIoYnJhbmNoU2xvdHMubGVuZ3RoIC0gbm9kZS5icmFuY2hPcmRlcigpKTtcbiAgICBub2RlLmFuY2VzdG9yT2ZIRUFEKG5vZGUuYW5jZXN0b3JPZkhFQURUaW1lU3RhbXAgPT0gdXBkYXRlVGltZVN0YW1wKTtcbiAgICBub2RlLmFib3ZlTm9kZSA9IHByZXZOb2RlO1xuICAgIGlmIChwcmV2Tm9kZSkgcHJldk5vZGUuYmVsb3dOb2RlID0gbm9kZTtcbiAgICBwcmV2Tm9kZSA9IG5vZGU7XG4gIH0pO1xuXG4gIHJldHVybiBub2Rlcztcbn1cblxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbihub2RlQXNoYTEsIG5vZGVCc2hhMSkge1xuICB2YXIgaWQgPSBub2RlQXNoYTEgKyAnLScgKyBub2RlQnNoYTE7XG4gIHZhciBlZGdlID0gdGhpcy5lZGdlc0J5SWRbaWRdO1xuICBpZiAoIWVkZ2UpIHtcbiAgICBlZGdlID0gdGhpcy5lZGdlc0J5SWRbaWRdID0gbmV3IEVkZ2VWaWV3TW9kZWwodGhpcywgbm9kZUFzaGExLCBub2RlQnNoYTEpO1xuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5fbWFya0lkZW9sb2dpY2FsU3RhbXAgPSAwO1xuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLm1hcmtOb2Rlc0lkZW9sb2dpY2FsQnJhbmNoZXMgPSBmdW5jdGlvbihyZWZzLCBub2Rlcywgbm9kZXNCeUlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVmcyA9IHJlZnMuZmlsdGVyKGZ1bmN0aW9uKHIpIHsgcmV0dXJuICEhci5ub2RlKCk7IH0pO1xuICByZWZzID0gcmVmcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYS5pc0xvY2FsICYmICFiLmlzTG9jYWwpIHJldHVybiAtMTtcbiAgICBpZiAoYi5pc0xvY2FsICYmICFhLmlzTG9jYWwpIHJldHVybiAxO1xuICAgIGlmIChhLmlzQnJhbmNoICYmICFiLmlzQnJhbmNoKSByZXR1cm4gLTE7XG4gICAgaWYgKGIuaXNCcmFuY2ggJiYgIWEuaXNCcmFuY2gpIHJldHVybiAxO1xuICAgIGlmIChhLmlzSEVBRCAmJiAhYi5pc0hFQUQpIHJldHVybiAxO1xuICAgIGlmICghYS5pc0hFQUQgJiYgYi5pc0hFQUQpIHJldHVybiAtMTtcbiAgICBpZiAoYS5pc1N0YXNoICYmICFiLmlzU3Rhc2gpIHJldHVybiAxO1xuICAgIGlmIChiLmlzU3Rhc2ggJiYgIWEuaXNTdGFzaCkgcmV0dXJuIC0xO1xuICAgIGlmIChhLm5vZGUoKSAmJiBhLm5vZGUoKS5kYXRlICYmIGIubm9kZSgpICYmIGIubm9kZSgpLmRhdGUpXG4gICAgICByZXR1cm4gYi5ub2RlKCkuZGF0ZSAtIGEubm9kZSgpLmRhdGU7XG4gICAgcmV0dXJuIGEucmVmTmFtZSA8IGIucmVmTmFtZSA/IC0xIDogMTtcbiAgfSk7XG4gIHZhciBzdGFtcCA9IEdyYXBoVmlld01vZGVsLl9tYXJrSWRlb2xvZ2ljYWxTdGFtcCsrO1xuICByZWZzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgc2VsZi50cmF2ZXJzZU5vZGVQYXJlbnRzKHJlZi5ub2RlKCksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnN0YW1wID09IHN0YW1wKSByZXR1cm4gZmFsc2U7XG4gICAgICBub2RlLnN0YW1wID0gc3RhbXA7XG4gICAgICBub2RlLmlkZW9sb2dpY2FsQnJhbmNoKHJlZik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS50cmF2ZXJzZU5vZGVQYXJlbnRzID0gZnVuY3Rpb24obm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjayhub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucGFyZW50cygpLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gaWYgcGFyZW50LCB0cmF2ZXJzIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSB0aGlzLm5vZGVzQnlJZFtub2RlLnBhcmVudHMoKVtpXV07XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy50cmF2ZXJzZU5vZGVQYXJlbnRzKHBhcmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUuaGFuZGxlQnViYmxlZENsaWNrID0gZnVuY3Rpb24oZWxlbSwgZXZlbnQpIHtcbiAgLy8gSWYgdGhlIGNsaWNrZWQgZWxlbWVudCBpcyBib3VuZCB0byB0aGUgY3VycmVudCBhY3Rpb24gY29udGV4dCxcbiAgLy8gdGhlbiBsZXQncyBub3QgZGVzZWxlY3QgaXQuXG4gIGlmIChrby5kYXRhRm9yKGV2ZW50LnRhcmdldCkgPT09IHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSkgcmV0dXJuO1xuICBpZiAodGhpcy5jdXJyZW50QWN0aW9uQ29udGV4dCgpICYmIHRoaXMuY3VycmVudEFjdGlvbkNvbnRleHQoKSBpbnN0YW5jZW9mIEdpdE5vZGVWaWV3TW9kZWwpIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KCkudG9nZ2xlU2VsZWN0ZWQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICB9XG4gIC8vIElmIHRoZSBjbGljayB3YXMgb24gYW4gaW5wdXQgZWxlbWVudCwgdGhlbiBsZXQncyBhbGxvdyB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gcHJvY2VlZC5cbiAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IG5lZWRlZCBzaW5jZSBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiBhbnkgc3VibWl0IChpZS4gZW50ZXIgaW4gYSB0ZXh0Ym94KVxuICAvLyB3aWxsIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgc3VibWl0IGlucHV0IG9mIHRoZSBmb3JtLCB3aGljaCB3aWxsIGVuZCB1cCBoZXJlLFxuICAvLyBhbmQgaWYgd2UgZG9uJ3QgcmV0dXJuIHRydWUsIHRoZW4gdGhlIHN1Ym1pdCBldmVudCBpcyBuZXZlciBmaXJlZCwgYnJlYWtpbmcgc3R1ZmYuXG4gIGlmIChldmVudC50YXJnZXQubm9kZU5hbWUgPT09ICdJTlBVVCcpIHJldHVybiB0cnVlO1xufVxuXG5HcmFwaFZpZXdNb2RlbC5wcm90b3R5cGUub25Qcm9ncmFtRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQuZXZlbnQgPT0gJ2dpdC1kaXJlY3RvcnktY2hhbmdlZCcpIHtcbiAgICB0aGlzLmxvYWROb2Rlc0Zyb21BcGlUaHJvdHRsZWQoKTtcbiAgICB0aGlzLnVwZGF0ZUJyYW5jaGVzVGhyb3R0bGVkKCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT0gJ3JlcXVlc3QtYXBwLWNvbnRlbnQtcmVmcmVzaCcpIHtcbiAgICB0aGlzLmxvYWROb2Rlc0Zyb21BcGlUaHJvdHRsZWQoKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAncmVtb3RlLXRhZ3MtdXBkYXRlJykge1xuICAgIHRoaXMuc2V0UmVtb3RlVGFncyhldmVudC50YWdzKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAnY3VycmVudC1yZW1vdGUtY2hhbmdlZCcpIHtcbiAgICB0aGlzLmN1cnJlbnRSZW1vdGUoZXZlbnQubmV3UmVtb3RlKTtcbiAgfSBlbHNlIGlmIChldmVudC5ldmVudCA9PSAnZ3JhcGgtcmVuZGVyJykge1xuICAgIHRoaXMubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUucmVuZGVyKCk7XG4gICAgfSk7XG4gIH1cbn1cbkdyYXBoVmlld01vZGVsLnByb3RvdHlwZS51cGRhdGVCcmFuY2hlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuc2VydmVyLmdldCgnL2NoZWNrb3V0JywgeyBwYXRoOiB0aGlzLnJlcG9QYXRoKCkgfSwgZnVuY3Rpb24oZXJyLCBicmFuY2gpIHtcbiAgICBpZiAoZXJyICYmIGVyci5lcnJvckNvZGUgPT0gJ25vdC1hLXJlcG9zaXRvcnknKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyKSByZXR1cm47XG4gICAgc2VsZi5jaGVja2VkT3V0QnJhbmNoKGJyYW5jaCk7XG4gIH0pO1xufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLnNldFJlbW90ZVRhZ3MgPSBmdW5jdGlvbihyZW1vdGVUYWdzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG5vZGVJZHNUb1JlbW90ZVRhZ3MgPSB7fTtcbiAgcmVtb3RlVGFncy5mb3JFYWNoKGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYubmFtZS5pbmRleE9mKCdee30nKSAhPSAtMSkge1xuICAgICAgdmFyIHRhZ1JlZiA9IHJlZi5uYW1lLnNsaWNlKDAsIHJlZi5uYW1lLmxlbmd0aCAtICdee30nLmxlbmd0aCk7XG4gICAgICB2YXIgbmFtZSA9ICdyZW1vdGUtdGFnOiAnICsgcmVmLnJlbW90ZSArICcvJyArIHRhZ1JlZi5zcGxpdCgnLycpWzJdO1xuICAgICAgc2VsZi5nZXRSZWYobmFtZSkubm9kZShzZWxmLmdldE5vZGUocmVmLnNoYTEpKTtcbiAgICB9XG4gIH0pO1xufVxuR3JhcGhWaWV3TW9kZWwucHJvdG90eXBlLmNoZWNrSGVhZE1vdmUgPSBmdW5jdGlvbih0b05vZGUpIHtcbiAgaWYgKHRoaXMuSEVBRCgpID09PSB0b05vZGUpIHtcbiAgICB0aGlzLkhFQURyZWYubm9kZSh0b05vZGUpO1xuICB9XG59XG4iLCJ2YXIgZ2V0RWRnZU1vZGVsV2l0aEQgPSBmdW5jdGlvbihkLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXksIG1hcmtlckVuZCkge1xuICByZXR1cm4geyBkOiBkLFxuICAgICAgICAgIHN0cm9rZTogc3Ryb2tlID8gc3Ryb2tlIDogJyM0QTRBNEEnLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/IHN0cm9rZVdpZHRoIDogJzgnLFxuICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5ID8gc3Ryb2tlRGFzaGFycmF5IDogJzEwLCA1JyxcbiAgICAgICAgICBtYXJrZXJFbmQ6IG1hcmtlckVuZCA/IG1hcmtlckVuZCA6ICcnIH07XG59XG5cbnZhciBnZXRFZGdlTW9kZWwgPSBmdW5jdGlvbihzY3gsIHNjeSwgdGN4LCB0Y3ksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZURhc2hhcnJheSwgbWFya2VyRW5kKSB7XG4gIHJldHVybiBnZXRFZGdlTW9kZWxXaXRoRChcIk0gXCIgKyBzY3ggKyBcIiBcIiArIHNjeSArIFwiIEwgXCIgKyB0Y3ggKyBcIiBcIiArIHRjeSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlRGFzaGFycmF5LCBtYXJrZXJFbmQpO1xufVxuXG52YXIgZ2V0Tm9kZU1vZGVsID0gZnVuY3Rpb24oY3gsIGN5LCByLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VEYXNoYXJyYXkpIHtcbiAgcmV0dXJuIHsgY3g6IGN4LFxuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICByOiByLFxuICAgICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPyBzdHJva2UgOiAnIzQxREUzQycsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8gc3Ryb2tlV2lkdGggOiAnOCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiBzdHJva2VEYXNoYXJyYXkgPyBzdHJva2VEYXNoYXJyYXkgOiAnMTAsIDUnIH07XG59XG5cbmZ1bmN0aW9uIEhvdmVyVmlld01vZGVsKCkge1xuICB0aGlzLmJnRWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmZnRWRnZXMgPSBbXTtcbn1cblxuZnVuY3Rpb24gTWVyZ2VWaWV3TW9kZWwoZ3JhcGgsIGhlYWROb2RlLCBub2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLmJnRWRnZXMgPSBbIGdldEVkZ2VNb2RlbChoZWFkTm9kZS5jeCgpLCAoaGVhZE5vZGUuY3koKSAtIDExMCksIGhlYWROb2RlLmN4KCksIGhlYWROb2RlLmN5KCkpLFxuICAgICAgICAgICAgICAgIGdldEVkZ2VNb2RlbChoZWFkTm9kZS5jeCgpLCAoaGVhZE5vZGUuY3koKSAtIDExMCksIG5vZGUuY3goKSwgbm9kZS5jeSgpKSBdO1xuICB0aGlzLm5vZGVzID0gWyBnZXROb2RlTW9kZWwoaGVhZE5vZGUuY3goKSwgaGVhZE5vZGUuY3koKSAtIDExMCwgTWF0aC5tYXgoaGVhZE5vZGUucigpLCBub2RlLnIoKSksICcjMjUyODMzJywgJyM0MURFM0MnLCAnOCcsICcxMCwgNScpIF07XG5cbiAgZ3JhcGguZGltQ29tbWl0KHRydWUpO1xufVxuZXhwb3J0cy5NZXJnZVZpZXdNb2RlbCA9IE1lcmdlVmlld01vZGVsO1xuTWVyZ2VWaWV3TW9kZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ncmFwaC5kaW1Db21taXQoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBSZWJhc2VWaWV3TW9kZWwob250bywgbm9kZXNUaGF0V2lsbE1vdmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBIb3ZlclZpZXdNb2RlbC5jYWxsKHRoaXMpO1xuICBub2Rlc1RoYXRXaWxsTW92ZSA9IG5vZGVzVGhhdFdpbGxNb3ZlLnNsaWNlKDAsIC0xKTtcblxuICBpZiAobm9kZXNUaGF0V2lsbE1vdmUubGVuZ3RoID09IDApIHJldHVybjtcblxuICB0aGlzLmJnRWRnZXMucHVzaChnZXRFZGdlTW9kZWwob250by5jeCgpLCBvbnRvLmN5KCksIG9udG8uY3goKSwgb250by5jeSgpIC0gNjApKTtcbiAgbm9kZXNUaGF0V2lsbE1vdmUuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgdmFyIGN5ID0gb250by5jeSgpICsgKC05MCAqIChpICsgMSkpO1xuICAgIHNlbGYubm9kZXMucHVzaChnZXROb2RlTW9kZWwob250by5jeCgpLCBjeSwgMjgsICd0cmFuc3BhcmVudCcpKTtcbiAgICBpZiAoaSArIDEgPCBub2Rlc1RoYXRXaWxsTW92ZS5sZW5ndGgpIHtcbiAgICAgIHNlbGYuYmdFZGdlcy5wdXNoKGdldEVkZ2VNb2RlbChvbnRvLmN4KCksIChjeSAtIDI1KSwgb250by5jeCgpLCAoY3kgLSA2NSkpKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5SZWJhc2VWaWV3TW9kZWwgPSBSZWJhc2VWaWV3TW9kZWw7XG5cbmZ1bmN0aW9uIFJlc2V0Vmlld01vZGVsKG5vZGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBzZWxmLmZnRWRnZXMucHVzaChnZXRFZGdlTW9kZWxXaXRoRChub2RlLmdldExlZnRUb1JpZ2h0U3RyaWtlKCksICdyZ2IoMjU1LCAxMjksIDMxKScsICc4JywgJzAsIDAnKSlcbiAgICBzZWxmLmZnRWRnZXMucHVzaChnZXRFZGdlTW9kZWxXaXRoRChub2RlLmdldFJpZ2h0VG9MZWZ0U3RyaWtlKCksICdyZ2IoMjU1LCAxMjksIDMxKScsICc4JywgJzAsIDAnKSk7XG4gIH0pO1xufVxuZXhwb3J0cy5SZXNldFZpZXdNb2RlbCA9IFJlc2V0Vmlld01vZGVsO1xuXG5mdW5jdGlvbiBQdXNoVmlld01vZGVsKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgSG92ZXJWaWV3TW9kZWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5mZ0VkZ2VzID0gW2dldEVkZ2VNb2RlbChmcm9tTm9kZS5jeCgpLCBmcm9tTm9kZS5jeSgpLCB0b05vZGUuY3goKSwgKHRvTm9kZS5jeSgpICsgNDApLCAncmdiKDYxLCAxMzksIDI1NSknLCAnMTUnLCAnMTAsIDUnLCAndXJsKCNwdXNoQXJyb3dFbmQpJyApXTtcbn1cbmV4cG9ydHMuUHVzaFZpZXdNb2RlbCA9IFB1c2hWaWV3TW9kZWw7XG4iLCJ2YXIga28gPSByZXF1aXJlKCdrbm9ja291dCcpO1xuXG52YXIgU2VsZWN0YWJsZSA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuc2VsZWN0ZWQgPSBrby5jb21wdXRlZCh7XG4gICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSB0aGlzO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gdmFsIGlzIHRoaXMgaWYgd2UncmUgY2FsbGVkIGZyb20gYSBjbGljayBrbyBiaW5kaW5nXG4gICAgICBpZiAodmFsID09PSB0aGlzIHx8IHZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICBncmFwaC5jdXJyZW50QWN0aW9uQ29udGV4dCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JhcGguY3VycmVudEFjdGlvbkNvbnRleHQoKSA9PSB0aGlzKSB7XG4gICAgICAgIGdyYXBoLmN1cnJlbnRBY3Rpb25Db250ZXh0KG51bGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb3duZXI6IHRoaXNcbiAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RhYmxlO1xuIl19
