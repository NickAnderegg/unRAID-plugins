#!/usr/bin/php
<?php
##############################
######  DEAMON SECTION  ######
##############################
$cron         = FALSE;
$DEBUG        = FALSE;

# DO NOT TOUCH
set_time_limit(0);
$prog = pathinfo(__FILE__, PATHINFO_FILENAME);
$lockfile     = "/var/run/$prog.pid";
$service = __FILE__;
openlog($prog, LOG_PID | LOG_PERROR, LOG_LOCAL0);

$usage = <<<EOF

Process settings in ipmi plugin config. Control fans based on config values and [options].

Usage: $prog [options] = start daemon

  -c, --cron       create a cron job
  -d, --daemon      turn on debugging
  -q, --quit       terminate $prog if running
  -v, --verbose    print all messages
      --debug      turn on debugging
      --help       display this help and exit
      --version    output version information and exit


EOF;

$shortopts = "bc:dqv";
$longopts = [
	"cron:",
	"debug",
	"daemon",
	"help",
	"quiet",
	"quit",
	"verbose",
	"version"
];
$args = getopt($shortopts, $longopts);

if (array_key_exists("help", $args)) {
	echo $usage;
	exit(1);
}

if (array_key_exists("version", $args)) {
	echo "IPMI Fan Control: 1.0\n";
	exit(1);
}

$cron   = (array_key_exists("c", $args) || array_key_exists("cron", $args));
$daemon = (array_key_exists("d", $args) || array_key_exists("daemon", $args));
$quit   = (array_key_exists("q", $args) || array_key_exists("quit", $args));
$argv   = (array_key_exists("v", $args) || array_key_exists("verbose", $args));
$DEBUG  = (array_key_exists("debug", $args));

#############################################
# ipmi-raw 00 3a 01 00 00 00 00 00 00 00 00 #
# ipmi-raw 00 3a 01 AA BB CC DD EE FF GG HH #
# 0x00 = smartfan mode                      #
# 0x01 - 0x64  = 1% - 100%                  #
#############################################
$boards = [
	'ASRock' => [
		'raw' => '00 3a 01',
		'fans' => [
			'CPU_FAN1'  => '00', // AA
	  'CPU_FAN2'  => '00', // BB
	  'REAR_FAN1' => '00', // CC
	  'REAR_FAN2' => '00', // DD
	  'FRNT_FAN1' => '00', // EE
	  'FRNT_FAN2' => '00', // FF
	  'FRNT_FAN3' => '00', // GG
	  'FRNT_FAN4' => '00'] // HH
	]
];

function debug($m){
  global $prog, $DEBUG;
  if($DEBUG){
    $STDERR = fopen('php://stderr', 'w+');
    fwrite($STDERR, $m."\n");
    fclose($STDERR);
  }
}

# Deal with cron
if (($cron) && is_numeric($cron) && !$quit){
  exec("crontab -l 2>/dev/null", $crontab);
  $crontab = array_unique($crontab);
  if (!$quit){
    $entry = sprintf("*/%s * * * *  ${service}${background_args} 1> /dev/null 2>&1", $cron);
    if (! preg_grep("#${service}#", $crontab)){
      $crontab[] = $entry;
      debug("\nCRONTAB\n".implode("\n", $crontab)."\n");
      file_put_contents("/tmp/$prog.cron", implode(PHP_EOL, $crontab));
      shell_exec("crontab /tmp/$prog.cron");
      unlink("/tmp/$prog.cron");
    }
  }
  unset($crontab);
} else if ($quit){
  exec("crontab -l 2>/dev/null", $crontab);
  $crontab = array_unique($crontab);
  if (preg_grep("#${service}#", $crontab)){
    $crontab = preg_grep("#${service}#", $crontab, PREG_GREP_INVERT);
      debug("\nCRONTAB\n".implode("\n", $crontab)."\n");
    file_put_contents("/tmp/$prog.cron", implode(PHP_EOL, $crontab));
    shell_exec("crontab /tmp/$prog.cron");
    unlink("/tmp/$prog.cron");
  };
  unset($crontab);
}

if (is_file($lockfile)){
  $lock_pid = file($lockfile, FILE_IGNORE_NEW_LINES)[0];
  $pid = preg_replace("/\s+/", "", shell_exec("ps -p ${lock_pid}| grep ${lock_pid}"));
  if (!$pid){
    if (!$quit){
      file_put_contents($lockfile, getmypid());
    } else {
      echo "$lock_pid is not currently running";
      unlink($lockfile);
      exit(0);
    }
  } else {
    if ($quit){
      syslog(LOG_INFO, "killing daemon with PID [$lock_pid]");
      exec("kill $lock_pid");
      unlink($lockfile);
      if (function_exists('at_exit')) at_exit();
      exit(0);
    } else {
      echo "$prog is already running [$lock_pid]".PHP_EOL;
      exit(0);
    }
  }
} else {
  if($quit){
    echo "$prog not currently running".PHP_EOL;
    exit(0);
  } else {
    file_put_contents($lockfile, getmypid());
  }
}

/*if($daemon){
  exec("/usr/bin/php $service --daemon 1>/dev/null ".($DEBUG ? "":"2>&1 ")."&");
  exit(0);
} else {
  syslog(LOG_INFO, "process started. To terminate it, type: $prog -q");
}
*/
##############################
#####  PROGRAM SECTION  ######
##############################
require_once '/usr/local/emhttp/plugins/ipmi/include/ipmi_options.php';

/* scan directory for type */
function scan_dir($dir, $type = ""){
  $out = array();
  foreach (array_slice(scandir($dir), 2) as $entry){
    $sep   = (preg_match("/\/$/", $dir)) ? "" : "/";
    $out[] = $dir.$sep.$entry ;
  }
  return $out;
}

/* get highest temp of hard drives */
function get_highest_temp($hdds){
  $highest_temp="0";
  foreach ($hdds as $hdd) {
    if (shell_exec("hdparm -C ${hdd} 2>/dev/null| grep -c standby") == 0){
      $temp = preg_replace("/\s+/", "", shell_exec("smartctl -A ${hdd} 2>/dev/null| grep -m 1 -i Temperature_Celsius | awk '{print $10}'"));
      $highest_temp = ($temp > $highest_temp) ? $temp : $highest_temp;
    }
  } 
  debug("Highest temp is ${highest_temp}ÂºC");
  return $highest_temp;
}

/* get all hard drives except flash drive */
function get_all_hdds(){
  $hdds = array();
  $flash = preg_replace("/\d$/", "", realpath("/dev/disk/by-label/UNRAID"));
  foreach (scan_dir("/dev/") as $dev) {
    if(preg_match("/[sh]d[a-z]+$/", $dev) && $dev != $flash) {
      $hdds[] = $dev;
    }
  }
  return $hdds;
}

/* get reading for a given sensor by name */
function ipmi_get_sensors($options=null) {
	$cmd = "/usr/sbin/ipmi-sensors --comma-separated-output --ignore-not-available-sensors --no-header-output --interpret-oem-data $options 2>/dev/null";
	exec($cmd, $output, $return);

	if ($return)
		return []; // return empty array if error
	
	/* get highest hard drive temp and add sensor */
	$hdds =  get_all_hdds();
	$hdd_temp = get_highest_temp($hdds);
	$output[] = "99,HDD Temperature,Temperature,$hdd_temp,C,Ok";

	// key names for ipmi sensors output
	$keys = ['ID', 'Name', 'Type', 'Reading', 'Units', 'Event'];

	foreach($output as $line){

		// add sensor keys as keys to ipmi sensor output
		$sensor_raw = explode(",", $line);
		$size_raw = sizeof($sensor_raw);
		$sensor = ($size_raw < 6) ? []: array_combine($keys, array_slice($sensor_raw,0,6,true));
		
		if (($sensor['Type'] == 'Temperature' || $sensor['Type'] == 'Fan') && $sensor['State'] != 'N/A') {
			if (empty($options)){
				$sensors[$sensor['ID']] = $sensor;
			}else{
				//split id into host and id
				$id = explode(':',$sensor['ID']);
				$sensor['IP'] = trim($id[0]);
				$sensor['ID'] = trim($id[1]);
				if ($sensor['IP'] == 'localhost')
					$sensor['IP'] = '127.0.0.1';

				// add sensor to array of sensors
				$sensors[ip2long($sensor['IP']).'-'.$sensor['ID']] = $sensor;
			}
		}
	}
	return $sensors; // sensor readings
}

if(!empty($fan_cfg)){
	$board	= $fan_cfg['IPMIBOARD'];
	$raw		= $boards["$board"]['raw'];
	$fans		= $boards["$board"]['fans'];

	while(TRUE){ while(TRUE){
	####  DO YOUR STUFF HERE  ####

	//extract($fan_cfg, EXTR_OVERWRITE);

	/* Get sensor info and check connection */
	if($ipmi_mod || $ipmi_network == 'enable')
		$ipmi_sensors = ipmi_get_sensors($ipmi_options);

	# Wait probes to become ready
	/*if (!is_file($PWM_CONTROLLER) || ! is_file($PWM_FAN)){
		sleep(15);
		continue;
	}*/

	for ($i = 0; $i < 7; $i++) {
		if(isset($fan_cfg["FAN$i"])) {
			$ipmi_fan	= (isset($fan_cfg["FAN$i"]))		? $fan_cfg["FAN$i"] : 0 ;
			$ipmi_temp	= (isset($fan_cfg["FANTEMP$i"])) ? $fan_cfg["FANTEMP$i"] : 99;
			$temp_lo		= (isset($fan_cfg["TEMPLO$i"]))	? $fan_cfg["TEMPLO$i"] : 30;
			$temp_hi		= (isset($fan_cfg["TEMPHI$i"]))	? $fan_cfg["TEMPHI$i"] : 50;

			$temp			= $ipmi_sensors["$ipmi_temp"]['Reading'];
			$fan_name	= $ipmi_sensors["$ipmi_fan"]['Name'];

			if ($temp <= $temp_lo)
				$pwm = "01";
			else if ($temp >= $temp_hi)
				$pwm = "64";
			else
				$pwm = str_pad(round((($temp-$temp_lo)/($temp_hi-$temp_lo))*64), 2, '0', STR_PAD_LEFT);
			$fans["$fan_name"] = $pwm;
		}
	}
	$hex = "";
	foreach($fans as $fan){
		$hex .= " $fan";
	}
	$cmd = "ipmi-raw $raw$hex ";
	shell_exec($cmd.$options);
	syslog(LOG_INFO, "setting fans to $hex");

# PRINT VARIABLES DEBUG 
$defined_vars = get_defined_vars();
foreach (array("_GET","_POST","_COOKIE","_FILES","argv","argc","_SERVER") as $i) {unset($defined_vars[$i]);}
debug("\nDECLARED VARIABLES:\n".print_r($defined_vars, true));
unset($defined_vars);

$time1 = time();
//$MD5 = shell_exec("md5sum $fan_cfg_file|awk '{print $1}'");
$MD5 = md5_file($fan_cfg_file);
for ($i=0; $i < $fanpoll*6 ; $i++) { 
  sleep(10);
  //if (md5_file($fan_cfg_file) != $MD5){syslog(LOG_INFO, "config file updated, reloading."); $i=10000;}
}
debug("Sleep ".(time()-$time1)." seconds.");

######  END OF SECTION  ######
};
};
} else {
  unlink($lockfile);
  exit(1);
}

?>